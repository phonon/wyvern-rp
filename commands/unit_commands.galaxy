//=========================================================
//		Wyvern Roleplaying Engine
//		Copyright (c) 2014 , Xethyr.407 [NA] / @nmosfet
//=========================================================
// This software is distributed under the MIT License:
// <http://opensource.org/licenses/MIT>
//=========================================================

// libwyv_command_kill
// ====================
// kills units in player unitgroup context
bool libwyv_command_kill(bool testConds, bool runActions) {
	UnitGroupLoopBegin(libwyv_player[EventPlayer()].context);
	while(!UnitGroupLoopDone()) {
		UnitKill( UnitGroupLoopCurrent() );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

// libwyv_command_remove
// ====================
// removes units in player unitgroup context
bool libwyv_command_remove(bool testConds, bool runActions) {
	UnitGroupLoopBegin(libwyv_player[EventPlayer()].context);
	while(!UnitGroupLoopDone()) {
		UnitRemove(UnitGroupLoopCurrent());
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

// libwyv_command_removearea
// =====================
// removes unit in a radius around mouse position
bool libwyv_command_removearea(bool testConds, bool runActions) {
	unitgroup g;
	fixed radius = StringToFixed( StringWord( libwyv_player[EventPlayer()].chat_msg, 2 ));
	if(radius == 0.0) {
		radius = 5.0;
	}

	g = UnitGroup( null, c_playerAny, RegionCircle( libwyv_player[EventPlayer()].mouse_position, radius), null, 0 );
	g = libwyv_enforce_unit_permissions(g, EventPlayer());

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		UnitRemove( UnitGroupLoopCurrent() );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	libNtve_gf_RemoveDeathModelsinRegion( RegionCircle( libwyv_player[EventPlayer()].mouse_position, radius) );

	return true;
}

// libwyv_command_cache
// ===================
// displays unit command cache info or values
bool libwyv_command_cache(bool testConds, bool runActions) {
	string cache;
	string unit_caches;
	unitgroup g = libwyv_player[EventPlayer()].context;

	cache = StringWord(libwyv_player[EventPlayer()].chat_msg, 2);

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		if(StringToInt(cache) == 0) { //display number of caches
			if(UnitGetCustomValue(UnitGroupLoopCurrent(), LIBWYV_UNIT_INDEX_CACHE_COUNT) == 1 && !DataTableValueExists(true, FixedToString(UnitGetCustomValue(UnitGroupLoopCurrent(), LIBWYV_UNIT_INDEX_ID), 0) + ".1")) {
				unit_caches = "0";
			}
			else {
				unit_caches = FixedToString(UnitGetCustomValue(UnitGroupLoopCurrent(), LIBWYV_UNIT_INDEX_CACHE_COUNT), 0);
			}
			libwyv_print_output(EventPlayer(), "Unit " + UnitGetType(UnitGroupLoopCurrent()) + " has " + unit_caches + " command caches (type \"@cache #\" to view a cache)");
		}
		else {
			if(DataTableValueExists(true, FixedToString(UnitGetCustomValue(UnitGroupLoopCurrent(), LIBWYV_UNIT_INDEX_ID), 0) + "." + cache)) {
				libwyv_print_output(EventPlayer(), "Unit " + UnitGetType(UnitGroupLoopCurrent()) + " cache " + cache + ":<n/>" + DataTableGetString(true, FixedToString(UnitGetCustomValue(UnitGroupLoopCurrent(), LIBWYV_UNIT_INDEX_ID), 0) + "." + cache));
			}
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

// libwyv_command_give
// =================
// gives another player units
bool libwyv_command_give(bool testConds, bool runActions) {
	unitgroup g = libwyv_player[EventPlayer()].context;
	int new_owner = libwyv_color_to_player( StringCase( StringWord(libwyv_player[EventPlayer()].chat_msg, 2), false ) );

	if(new_owner == -1) { // invalid entry by user
		return true;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		UnitSetOwner( UnitGroupLoopCurrent(), new_owner, true );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

// libwyv_command_renameall
// ===================
// renames all units (by replacing unit catalog name entry)
bool libwyv_command_renameall(bool testConds, bool runActions) {
	string val;
	unitgroup g = libwyv_player[EventPlayer()].context;
	val = libwyv_player[EventPlayer()].chat_msg;
	val = StringSub( val, StringFind(val, " ", c_stringCase)+1, StringLength(val)); // The remainder of the chat message.

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		CatalogFieldValueSet(c_gameCatalogUnit, UnitGetType(UnitGroupLoopCurrent()), "Name", UnitGetOwner(UnitGroupLoopCurrent()), val);
		libwyv_unit_cache_update(UnitGroupLoopCurrent(), "@renameall", libwyv_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

// libwyv_command_behaviors
// ====================
// prints a list of all unit behaviors and stack count (behaviors can stack)
bool libwyv_command_behaviors(bool testConds, bool runActions) {
	int count;
	string behavior;

	UnitGroupLoopBegin(libwyv_player[EventPlayer()].context);
	while(!UnitGroupLoopDone()) {
		// print unit name and ID
		libwyv_print_text(PlayerGroupSingle(EventPlayer()), StringToText("> Unit [ID: " + libwyv_unit_id(UnitGroupLoopCurrent()) + "] ") + libwyv_unit_get_name(UnitGroupLoopCurrent()) + StringToText(" behaviors:"));

		count = UnitBehaviorCountAll(UnitGroupLoopCurrent());
		if( count > 0 ) {
			while( count > 0 ) {
				behavior = UnitBehaviorGet(UnitGroupLoopCurrent(), count);
				libwyv_print_output(EventPlayer(), behavior + " (" + IntToString( UnitBehaviorCount(UnitGroupLoopCurrent(), behavior) ) + ")");
				count -= 1;
			}
		}
		else { // count == 0, no behaviors
			libwyv_print_output(EventPlayer(), "No behaviors");
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

// libwyv_command_addbehavior
// =====================
// adds a behavior to units
bool libwyv_command_addbehavior(bool testConds, bool runActions) {
	string val = StringWord( libwyv_player[EventPlayer()].chat_msg, 2 );

	// get full behavior name from catalog
	val = libwyv_catalog_get(c_gameCatalogBehavior, val);
	if(val == null) {
		libwyv_print_error(EventPlayer(), "<c val=\"ff0000\">Unable to add behavior</c>: No such behavior exists.");
		return true;
	}

	UnitGroupLoopBegin(libwyv_player[EventPlayer()].context);
	while(!UnitGroupLoopDone()) {
		UnitBehaviorAdd( UnitGroupLoopCurrent(), val, UnitGroupLoopCurrent(), 1 );
		libwyv_unit_cache_update(UnitGroupLoopCurrent(), "@addbehavior", libwyv_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

// libwyv_command_removebehavior
// =======================
// removes a behavior from units
bool libwyv_command_removebehavior(bool testConds, bool runActions) {
	string val = StringWord( libwyv_player[EventPlayer()].chat_msg, 2 );

	// get catalog entry from user input
	val = libwyv_catalog_get(c_gameCatalogBehavior, val);
	if(val == null) {
		libwyv_print_error(EventPlayer(), "<c val=\"ff0000\">Unable to remove behavior</c>: No such behavior exists.");
		return true;
	}

	UnitGroupLoopBegin(libwyv_player[EventPlayer()].context);
	while(!UnitGroupLoopDone()) {
		UnitBehaviorRemove( UnitGroupLoopCurrent(), val, 1 );
		libwyv_unit_cache_update(UnitGroupLoopCurrent(), "@removebehavior", libwyv_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

// libwyv_command_weapons
// =================
// prints a list of the weapons a unit currently has
bool libwyv_command_weapons(bool testConds, bool runActions) {
	int count;

	UnitGroupLoopBegin(libwyv_player[EventPlayer()].context);
	while(!UnitGroupLoopDone()) {
		// print unit name and ID
		libwyv_print_text(PlayerGroupSingle(EventPlayer()), StringToText("> Unit [ID: " + libwyv_unit_id(UnitGroupLoopCurrent()) + "] ") + libwyv_unit_get_name(UnitGroupLoopCurrent()) + StringToText(" weapons:"));

		count = UnitWeaponCount(UnitGroupLoopCurrent());
		if( count > 0 ) {
			while( count > 0 ) {
				libwyv_print_output(EventPlayer(), UnitWeaponGet(UnitGroupLoopCurrent(), count));
				count -= 1;
			}
		}
		else { // count == 0, no behaviors
			libwyv_print_output(EventPlayer(), "No weapons");
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

// libwyv_command_addweapon
// ====================
// adds a weapon to a given turret on a unit
//  -> if turret specified does not exist, defaults to CTurret
//     (default weapon turret)
bool libwyv_command_addweapon(bool testConds, bool runActions) {
	string weapon = StringWord(libwyv_player[EventPlayer()].chat_msg, 2);
	string turret = StringWord(libwyv_player[EventPlayer()].chat_msg, 3);

	if( turret == "" ) {
		turret = "CTurret";
	}

	weapon = libwyv_catalog_get(c_gameCatalogWeapon, weapon);
	if( weapon == null || CatalogEntryScope(c_gameCatalogWeapon, weapon) == weapon) {
		libwyv_print_error(EventPlayer(), "<c val=\"ff0000\">Unable to add weapon</c>: No such weapon exists.");
		return true;
	}

	// if turret is not default, use catalog get on turet
	if( turret != "CTurret") {
		turret = libwyv_catalog_get(c_gameCatalogTurret, turret);
		if( turret == null ) {
			libwyv_print_error(EventPlayer(), "<c val=\"ff0000\">Unable to add weapon</c>: No such turret exists.");
			return true;
		}
	}

	UnitGroupLoopBegin(libwyv_player[EventPlayer()].context);
	while( !UnitGroupLoopDone() ) {
		UnitWeaponAdd( UnitGroupLoopCurrent(), weapon, turret );
		libwyv_unit_cache_update(UnitGroupLoopCurrent(), "@addweapon", libwyv_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

// libwyv_command_removeweapon
// ====================
// removes a weapon from a unit
bool libwyv_command_removeweapon(bool testConds, bool runActions) {
	string weapon = StringWord( libwyv_player[EventPlayer()].chat_msg, 2 );

	// get catalog entry for weapon and make sure weapon is valid
	weapon = libwyv_catalog_get(c_gameCatalogWeapon, weapon);
	if ( weapon == null || CatalogEntryScope(c_gameCatalogWeapon, weapon) == weapon) {
		libwyv_print_error(EventPlayer(), "<c val=\"ff0000\">Unable to remove weapon</c>: No such weapon exists.");
		return true;
	}

	UnitGroupLoopBegin(libwyv_player[EventPlayer()].context);
	while( !UnitGroupLoopDone() ) {
		UnitWeaponRemove( UnitGroupLoopCurrent(), weapon );
		libwyv_unit_cache_update(UnitGroupLoopCurrent(), "@removeweapon", libwyv_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

// libwyv_command_life
// libwyv_command_shields
// libwyv_command_energy
// ===================
// sets units life, shields, or energy (absolute, adding, or percentage)
// e.g. syntax: @life 10, @life 10%, @life +10, @life +10%
bool libwyv_command_life(bool testConds, bool runActions) {
	string param;
	fixed val;
	bool percent = false;
	unitgroup g = libwyv_player[EventPlayer()].context;
	bool absolute = true;

	param = StringWord( libwyv_player[EventPlayer()].chat_msg, 2 );

	if( StringContains(param, "%", c_stringEnd, c_stringCase) ) {
		percent = true;
		param = StringSub(param, 1, StringLength(param)-1);
	}
	if( StringContains(param, "+", c_stringBegin, c_stringCase) ) {
		absolute = false;
		param = StringSub(param, 2, StringLength(param));
	}

	val = StringToFixed(param);

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		if(!absolute) {
			if(percent) {
				UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropLife, UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropLife, c_unitPropCurrent) + (UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropLifeMax, c_unitPropCurrent)*(val/100)) );
			}
			else {
				UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropLife, UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropLife, c_unitPropCurrent) + val );
			}
		}
		else {
			if(percent) {
				UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropLifePercent, val );
			}
			else {
				UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropLife, val );
			}
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

bool libwyv_command_shields(bool testConds, bool runActions) {
	string param;
	fixed val;
	bool percent = false;
	unitgroup g = libwyv_player[EventPlayer()].context;
	bool absolute = true;

	param = StringWord( libwyv_player[EventPlayer()].chat_msg, 2 );

	if( StringContains(param, "%", c_stringEnd, c_stringCase) ) {
		percent = true;
		param = StringSub(param, 1, StringLength(param)-1);
	}
	if( StringContains(param, "+", c_stringBegin, c_stringCase) ) {
		absolute = false;
		param = StringSub(param, 2, StringLength(param));
	}

	val = StringToFixed(param);

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		if(!absolute) {
			if(percent) {
				UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropShields, UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropShields, c_unitPropCurrent) + (UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropShieldsMax, c_unitPropCurrent)*(val/100)) );
			}
			else {
				UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropShields, UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropShields, c_unitPropCurrent) + val );
			}
		}
		else {
			if(percent) {
				UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropShieldsPercent, val );
			}
			else {
				UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropShields, val );
			}
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

bool libwyv_command_energy(bool testConds, bool runActions) {
	string param;
	fixed val;
	bool percent = false;
	unitgroup g = libwyv_player[EventPlayer()].context;
	bool absolute = true;

	param = StringWord( libwyv_player[EventPlayer()].chat_msg, 2 );

	if( StringContains(param, "%", c_stringEnd, c_stringCase) ) {
		percent = true;
		param = StringSub(param, 1, StringLength(param)-1);
	}
	if( StringContains(param, "+", c_stringBegin, c_stringCase) ) {
		absolute = false;
		param = StringSub(param, 2, StringLength(param));
	}

	val = StringToFixed(param);

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		if(!absolute) {
			if(percent) {
				UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropEnergy, UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropEnergy, c_unitPropCurrent) + (UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropEnergyMax, c_unitPropCurrent)*(val/100)) );
			}
			else {
				UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropEnergy, UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropEnergy, c_unitPropCurrent) + val );
			}
		}
		else {
			if(percent) {
				UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropEnergyPercent, val );
			}
			else {
				UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropEnergy, val );
			}
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

// libwyv_command_maxlife
// libwyv_command_maxshields
// libwyv_command_maxenergy
// =====================
// sets a unit's maxlife, maxshields, or maxenergy
// can specify as either absolute, percentage, or added value
// e.g. syntax: @maxlife 10, @maxlife 10%, @maxlife +10%, @maxlife +10
bool libwyv_command_maxlife(bool testConds, bool runActions) {
	string param;
	fixed val;
	bool percent = false;
	unitgroup g = libwyv_player[EventPlayer()].context;
	bool absolute = true;

	param = StringWord( libwyv_player[EventPlayer()].chat_msg, 2 );

	if( StringContains(param, "%", c_stringEnd, c_stringCase) ) {
		percent = true;
		param = StringSub(param, 1, StringLength(param)-1);
	}
	if( StringContains(param, "+", c_stringBegin, c_stringCase) ) {
		absolute = false;
		param = StringSub(param, 2, StringLength(param));
	}

	val = StringToFixed(param);

	if( val <= 0 && absolute) {
		return true;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		if(!absolute) {
			if(percent) {
				val = UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropLifeMax, c_unitPropCurrent) + (UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropLifeMax, c_unitPropCurrent)*(val/100));
			}
			else {
				val = UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropLifeMax, c_unitPropCurrent) + val;
			}
		}
		else if(percent) {
			val = UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropLifeMax, c_unitPropCurrent)*(val/100);
		}
		if(UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropLifeMax, c_unitPropCurrent) + val < 0) {
			val = 1;
		}
		UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropLifeMax, val );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

bool libwyv_command_maxshields(bool testConds, bool runActions) {
	string param;
	fixed val;
	bool percent = false;
	unitgroup g = libwyv_player[EventPlayer()].context;
	bool absolute = true;

	param = StringWord( libwyv_player[EventPlayer()].chat_msg, 2 );

	if( StringContains(param, "%", c_stringEnd, c_stringCase) ) {
		percent = true;
		param = StringSub(param, 1, StringLength(param)-1);
	}
	if( StringContains(param, "+", c_stringBegin, c_stringCase) ) {
		absolute = false;
		param = StringSub(param, 2, StringLength(param));
	}

	val = StringToFixed(param);

	if( val <= 0 && absolute) {
		return true;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		if(!absolute) {
			if(percent) {
				val = UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropShieldsMax, c_unitPropCurrent) + (UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropShieldsMax, c_unitPropCurrent)*(val/100));
			}
			else {
				val = UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropShieldsMax, c_unitPropCurrent) + val;
			}
		}
		else if(percent) {
			val = UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropShieldsMax, c_unitPropCurrent)*(val/100);
		}
		if(UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropShieldsMax, c_unitPropCurrent) + val < 0) {
			val = 1;
		}
		UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropShieldsMax, val );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

bool libwyv_command_maxenergy(bool testConds, bool runActions) {
	string param;
	fixed val;
	bool percent = false;
	unitgroup g = libwyv_player[EventPlayer()].context;
	bool absolute = true;

	param = StringWord( libwyv_player[EventPlayer()].chat_msg, 2 );

	if( StringContains(param, "%", c_stringEnd, c_stringCase) ) {
		percent = true;
		param = StringSub(param, 1, StringLength(param)-1);
	}
	if( StringContains(param, "+", c_stringBegin, c_stringCase) ) {
		absolute = false;
		param = StringSub(param, 2, StringLength(param));
	}

	val = StringToFixed(param);

	if( val <= 0 && absolute) {
		return true;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		if(!absolute) {
			if(percent) {
				val = UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropEnergyMax, c_unitPropCurrent) + (UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropEnergyMax, c_unitPropCurrent)*(val/100));
			}
			else {
				val = UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropEnergyMax, c_unitPropCurrent) + val;
			}
		}
		else if(percent) {
			val = UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropEnergyMax, c_unitPropCurrent)*(val/100);
		}
		if(UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropEnergyMax, c_unitPropCurrent) + val < 0) {
			val = 1;
		}
		UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropEnergyMax, val );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

// libwyv_command_liferegen
// libwyv_command_shieldsregen
// libwyv_command_energyregen
// =========================
// changes units life, shields, or energy regeneration
// can specify as absolute or as a percentage
// e.g. syntax: @liferegen 2 or @liferegen 2%
bool libwyv_command_liferegen(bool testConds, bool runActions) {
	string param = StringWord( libwyv_player[EventPlayer()].chat_msg, 2 );
	fixed val = StringToFixed(param);
	bool is_percent = false;
	unitgroup g = libwyv_player[EventPlayer()].context;

	if( StringContains(param, "%", c_stringEnd, c_stringCase) ) {
		param = StringSub(param, 1, StringLength(param)-1);
		val = StringToFixed(param);
		is_percent = true;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		if(is_percent) {
			UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropLifeRegen,
				val * UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropLifeMax, false));
		}
		else {
			UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropLifeRegen, val );
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

bool libwyv_command_shieldsregen(bool testConds, bool runActions) {
	string param = StringWord( libwyv_player[EventPlayer()].chat_msg, 2 );
	fixed val = StringToFixed(param);
	bool is_percent = false;
	unitgroup g = libwyv_player[EventPlayer()].context;

	if( StringContains(param, "%", c_stringEnd, c_stringCase) ) {
		param = StringSub(param, 1, StringLength(param)-1);
		val = StringToFixed(param);
		is_percent = true;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		if(is_percent) {
			UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropShieldsRegen,
				val * UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropShieldsMax, false));
		}
		else {
			UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropShieldsRegen, val );
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

bool libwyv_command_energyregen(bool testConds, bool runActions) {
	string param = StringWord( libwyv_player[EventPlayer()].chat_msg, 2 );
	fixed val = StringToFixed(param);
	bool is_percent = false;
	unitgroup g = libwyv_player[EventPlayer()].context;

	if( StringContains(param, "%", c_stringEnd, c_stringCase) ) {
		param = StringSub(param, 1, StringLength(param)-1);
		val = StringToFixed(param);
		is_percent = true;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		if(is_percent) {
			UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropEnergyRegen,
				val * UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropEnergyMax, false));
		}
		else {
			UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropEnergyRegen, val );
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

// libwyv_command_speed
// ==================
// sets a unit's speed (either for a single unit, or permanently for all)
bool libwyv_command_speed(bool testConds, bool runActions) {
	string param = StringWord( libwyv_player[EventPlayer()].chat_msg, 2 );
	fixed val;
	bool is_permanent = false;
	bool absolute = true;
	unitgroup g = libwyv_player[EventPlayer()].context;

	is_permanent = StringContains(libwyv_player[EventPlayer()].chat_msg, "all", c_stringAnywhere, false) ||
				  StringContains(libwyv_player[EventPlayer()].chat_msg, "permanent", c_stringAnywhere, false);

	if( StringContains(param, "+", c_stringBegin, c_stringCase) ) {
		absolute = false;
		param = StringSub(param, 2, StringLength(param));
	}

	val = StringToFixed(param);

	if( val < 0 && absolute) {
		val = 0;
	}

	UnitGroupLoopBegin(g);
	if(is_permanent) {
		while(!UnitGroupLoopDone()) {
			if(!absolute) {
				val = UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropMovementSpeed, c_unitPropCurrent) + val;
				if(val < 0) {
					val = 0.0;
				}
			}
			CatalogFieldValueSet(c_gameCatalogUnit, UnitGetType(UnitGroupLoopCurrent()),
				"Speed", UnitGetOwner(UnitGroupLoopCurrent()), FixedToString(val, 4));
			UnitGroupLoopStep();
		}
	}
	else {
		while(!UnitGroupLoopDone()) {
			if(!absolute) {
				val = UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropMovementSpeed, c_unitPropCurrent) + val;
				if(val < 0) {
					val = 0.0;
				}
			}
			UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropMovementSpeed, val );
			UnitGroupLoopStep();
		}
	}
	UnitGroupLoopEnd();

	return true;
}

// libwyv_command_height
// ====================
// sets a unit's z height
bool libwyv_command_height(bool testConds, bool runActions) {
	fixed height;
	fixed time;
	string param;
	unitgroup g = libwyv_player[EventPlayer()].context;
	param = StringWord( libwyv_player[EventPlayer()].chat_msg, 2 );
	height = StringToFixed( param );
	param = StringWord( libwyv_player[EventPlayer()].chat_msg, 3 );
	time = StringToFixed( param );

	UnitGroupLoopBegin(g);
	while( !UnitGroupLoopDone() ) {
		UnitSetHeight( UnitGroupLoopCurrent(), height, time );
		libwyv_unit_cache_update(UnitGroupLoopCurrent(), "@height", libwyv_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

// libwyv_command_color
// ==================
// changes the player color of a unit
bool libwyv_command_color(bool testConds, bool runActions) {
	int new_color;
	string param = StringWord( libwyv_player[EventPlayer()].chat_msg, 2 );
	unitgroup g = libwyv_player[EventPlayer()].context;

	new_color = libwyv_color_to_player_default(param);
	if(new_color == -1) { // invalid entry by user
		return true;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		UnitSetTeamColorIndex( UnitGroupLoopCurrent(), new_color );
		libwyv_unit_cache_update(UnitGroupLoopCurrent(), "@color", libwyv_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

// libwyv_command_invulnerable
// libwyv_command_vulnerable
// ====================
// Makes a unit invulnerable or vulnerable
bool libwyv_command_invulnerable(bool testConds, bool runActions) {
	UnitGroupLoopBegin(libwyv_player[EventPlayer()].context);
	while(!UnitGroupLoopDone()) {
		UnitSetState( UnitGroupLoopCurrent(), c_unitStateInvulnerable, true );
		libwyv_unit_cache_update(UnitGroupLoopCurrent(), "@invulnerable", libwyv_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}
bool libwyv_command_vulnerable(bool testConds, bool runActions) {
	UnitGroupLoopBegin(libwyv_player[EventPlayer()].context);
	while(!UnitGroupLoopDone()) {
		UnitSetState( UnitGroupLoopCurrent(), c_unitStateInvulnerable, false );
		libwyv_unit_cache_update(UnitGroupLoopCurrent(), "@invulnerable", "");
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

// libwyv_command_face
// ===============
// makes a unit face an angle. (modified from Cortex engine)
// if no angle is specified, unit will face towards player's mouse cursor
bool libwyv_command_face(bool testConds, bool runActions) {
	fixed angle;
	string param;
	bool absolute = true;

	param = StringWord( libwyv_player[EventPlayer()].chat_msg, 2 );
	if( param != "" ) {
		if( StringContains(param, "+", c_stringBegin, c_stringCase) ) {
			absolute = false;
			param = StringSub(param, 2, StringLength(param));
		}
		angle = StringToFixed( param );
	}

	UnitGroupLoopBegin(libwyv_player[EventPlayer()].context);
	while(!UnitGroupLoopDone()) {
		if( param == "" ) { // face mouse
			libNtve_gf_MakeUnitFacePoint( UnitGroupLoopCurrent(), libwyv_player[EventPlayer()].mouse_position, 0.0 );
		}
		else if(!absolute) {
			UnitSetFacing(UnitGroupLoopCurrent(), UnitGetFacing(UnitGroupLoopCurrent()) + angle, 0.0);
		}
		else { // face angle
			UnitSetFacing( UnitGroupLoopCurrent(), angle, 0.0 );
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

// libwyv_command_damage
// =================
// deals with both adding or removing damage (modified from Cortex engine)
// both @adddamage and @removedamage are directed here
// max damage added or removed is currently set at 9999
bool libwyv_command_damage(bool testConds, bool runActions) {
	string command = StringCase( StringWord( libwyv_player[EventPlayer()].chat_msg, 1 ), false );
	string dmg_behavior_1;
	string dmg_behavior_10;
	string dmg_behavior_100;
	string dmg_behavior_1000;
	int amt;
	int val = StringToInt(StringWord( libwyv_player[EventPlayer()].chat_msg, 2 ));
	unitgroup g = libwyv_player[EventPlayer()].context;

	// since we are using the same command for both @adddamage and @removedamage,
	// check which command it is, and set proper behaviors
	if( (command == "@adddamage" && val > 0) || (command == "@removedamage" && val < 0) ) {
		dmg_behavior_1 = LIBWYV_BEHAVIOR_ADD_DAMAGE_1;
		dmg_behavior_10 = LIBWYV_BEHAVIOR_ADD_DAMAGE_10;
		dmg_behavior_100 = LIBWYV_BEHAVIOR_ADD_DAMAGE_100;
		dmg_behavior_1000 = LIBWYV_BEHAVIOR_ADD_DAMAGE_1000;
	}
	else { // we are using @removedamage
		dmg_behavior_1 = LIBWYV_BEHAVIOR_SUBTRACT_DAMAGE_1;
		dmg_behavior_10 = LIBWYV_BEHAVIOR_SUBTRACT_DAMAGE_10;
		dmg_behavior_100 = LIBWYV_BEHAVIOR_SUBTRACT_DAMAGE_100;
		dmg_behavior_1000 = LIBWYV_BEHAVIOR_SUBTRACT_DAMAGE_1000;
	}

	val = AbsI(val);
	if(val > 9999) {
	   val = 9999;
	}

	amt = val;

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		// First remove all damage bonuses and maluses, since we're now treating this as a "strictly positive setdamagebonus" command
		UnitBehaviorRemove( UnitGroupLoopCurrent(), LIBWYV_BEHAVIOR_ADD_DAMAGE_1, -1);
		UnitBehaviorRemove( UnitGroupLoopCurrent(), LIBWYV_BEHAVIOR_ADD_DAMAGE_10, -1);
		UnitBehaviorRemove( UnitGroupLoopCurrent(), LIBWYV_BEHAVIOR_ADD_DAMAGE_100, -1);
		UnitBehaviorRemove( UnitGroupLoopCurrent(), LIBWYV_BEHAVIOR_ADD_DAMAGE_1000, -1);
		UnitBehaviorRemove( UnitGroupLoopCurrent(), LIBWYV_BEHAVIOR_SUBTRACT_DAMAGE_1, -1);
		UnitBehaviorRemove( UnitGroupLoopCurrent(), LIBWYV_BEHAVIOR_SUBTRACT_DAMAGE_10, -1);
		UnitBehaviorRemove( UnitGroupLoopCurrent(), LIBWYV_BEHAVIOR_SUBTRACT_DAMAGE_100, -1);
		UnitBehaviorRemove( UnitGroupLoopCurrent(), LIBWYV_BEHAVIOR_SUBTRACT_DAMAGE_1000, -1);

		val = amt;

		// Add appropriate behaviors until they reach the desired total damage bonus
		while(val >= 1000) {
			UnitBehaviorAdd( UnitGroupLoopCurrent(), dmg_behavior_1000, UnitGroupLoopCurrent(), 1 );
			val -= 1000;
		}
		while(val >= 100) {
			UnitBehaviorAdd( UnitGroupLoopCurrent(), dmg_behavior_100, UnitGroupLoopCurrent(), 1 );
			val -= 100;
		}
		while(val >= 10) {
			UnitBehaviorAdd( UnitGroupLoopCurrent(), dmg_behavior_10, UnitGroupLoopCurrent(), 1 );
			val -= 10;
		}
		UnitBehaviorAdd( UnitGroupLoopCurrent(), dmg_behavior_1, UnitGroupLoopCurrent(), val );

		libwyv_unit_cache_update(UnitGroupLoopCurrent(), "@adddamage", libwyv_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

// libwyv_command_range
// =================
// deals with both adding or removing weapon range (modified from Cortex engine)
// both @addrange and @removerange are directed here
// max range able to be added/removed is currently set as 100
bool libwyv_command_range(bool testConds, bool runActions) {
	string command = StringCase( StringWord( libwyv_player[EventPlayer()].chat_msg, 1 ), false );
	string range_behavior_1;
	string range_behavior_10;
	int range = StringToInt( StringWord( libwyv_player[EventPlayer()].chat_msg, 2 ) );
	unitgroup g = libwyv_player[EventPlayer()].context;

	// since we are using the same command for both @addrange and @removerange,
	// check which command it is, and set proper behaviors
	if( (command == "@addrange" && range > 0) || (command == "@removerange" && range < 0) ) {
		range_behavior_1 = LIBWYV_BEHAVIOR_ADD_RANGE_1;
		range_behavior_10 = LIBWYV_BEHAVIOR_ADD_RANGE_10;
	}
	else { // are removing range
		range_behavior_1 = LIBWYV_BEHAVIOR_SUBTRACT_RANGE_1;
		range_behavior_10 = LIBWYV_BEHAVIOR_SUBTRACT_RANGE_10;
	}

	range = AbsI(range);
	if(range > 100) {
		range = 100;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		UnitBehaviorRemove(UnitGroupLoopCurrent(), LIBWYV_BEHAVIOR_ADD_RANGE_1, -1);
		UnitBehaviorRemove(UnitGroupLoopCurrent(), LIBWYV_BEHAVIOR_ADD_RANGE_10, -1);
		UnitBehaviorRemove(UnitGroupLoopCurrent(), LIBWYV_BEHAVIOR_SUBTRACT_RANGE_1, -1);
		UnitBehaviorRemove(UnitGroupLoopCurrent(), LIBWYV_BEHAVIOR_SUBTRACT_RANGE_10, -1);

		UnitBehaviorAdd(UnitGroupLoopCurrent(), range_behavior_1, null, ModI(range, 10));
		UnitBehaviorAdd(UnitGroupLoopCurrent(), range_behavior_10, null, range / 10);

		libwyv_unit_cache_update(UnitGroupLoopCurrent(), "@addrange", libwyv_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

// libwyv_command_armor
// ===============
// used for both @armor and @shieldsarmor
// sets a unit's armor to the amount given via behaviors
bool libwyv_command_armor(bool testConds, bool runActions) {
	fixed armor = StringToFixed( StringWord( libwyv_player[EventPlayer()].chat_msg, 2 ) );
	fixed armor_curr = 0;
	fixed armor_diff = 0;
	string behav_armor_add_p1;
	string behav_armor_add_1;
	string behav_armor_add_10;
	string behav_armor_subtract_p1;
	string behav_armor_subtract_1;
	string behav_armor_subtract_10;
	unit current;
	unitgroup g = libwyv_player[EventPlayer()].context;

	if( StringCase( StringWord( libwyv_player[EventPlayer()].chat_msg, 1 ), false ) == "@shieldsarmor" ) {
		behav_armor_add_p1 = LIBWYV_BEHAVIOR_ADD_SHIELDSARMOR_P1;
		behav_armor_add_1 = LIBWYV_BEHAVIOR_ADD_SHIELDSARMOR_1;
		behav_armor_add_10 = LIBWYV_BEHAVIOR_ADD_SHIELDSARMOR_10;
		behav_armor_subtract_p1 = LIBWYV_BEHAVIOR_SUBTRACT_SHIELDSARMOR_P1;
		behav_armor_subtract_1 = LIBWYV_BEHAVIOR_SUBTRACT_SHIELDSARMOR_1;
		behav_armor_subtract_10 = LIBWYV_BEHAVIOR_SUBTRACT_SHIELDSARMOR_10;
	}
	else { // using @armor
		behav_armor_add_p1 = LIBWYV_BEHAVIOR_ADD_LIFEARMOR_P1;
		behav_armor_add_1 = LIBWYV_BEHAVIOR_ADD_LIFEARMOR_1;
		behav_armor_add_10 = LIBWYV_BEHAVIOR_ADD_LIFEARMOR_10;
		behav_armor_subtract_p1 = LIBWYV_BEHAVIOR_SUBTRACT_LIFEARMOR_P1;
		behav_armor_subtract_1 = LIBWYV_BEHAVIOR_SUBTRACT_LIFEARMOR_1;
		behav_armor_subtract_10 = LIBWYV_BEHAVIOR_SUBTRACT_LIFEARMOR_10;
	}

	if(armor > 255) {
		armor = 255;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		current = UnitGroupLoopCurrent();
		armor_curr = StringToFixed(CatalogFieldValueGet(c_gameCatalogUnit, UnitGetType(current), "LifeArmor", UnitGetOwner(current)));
		armor_diff = armor - armor_curr;

		// remove any existing armor behaviors
		UnitBehaviorRemove(current, behav_armor_add_p1, -1);
		UnitBehaviorRemove(current, behav_armor_add_1, -1);
		UnitBehaviorRemove(current, behav_armor_add_10, -1);
		UnitBehaviorRemove(current, behav_armor_subtract_p1, -1);
		UnitBehaviorRemove(current, behav_armor_subtract_1, -1);
		UnitBehaviorRemove(current, behav_armor_subtract_10, -1);

		if(armor_diff > 0) {
			while(armor_diff >= 10) {
				UnitBehaviorAdd(current, behav_armor_add_10, null, 1);
				armor_diff = armor_diff - 10;
			}
			while(armor_diff >= 1) {
				UnitBehaviorAdd(current, behav_armor_add_1, null, 1);
				armor_diff = armor_diff - 1;
			}
			while(armor_diff >= 0.1) {
				UnitBehaviorAdd(current, behav_armor_add_p1, null, 1);
				armor_diff = armor_diff - 0.1;
			}
		}
		else {
			while(armor_diff <= -10) {
				UnitBehaviorAdd(current, behav_armor_subtract_10, null, 1);
				armor_diff = armor_diff + 10;
			}
			while(armor_diff <= -1) {
				UnitBehaviorAdd(current, behav_armor_subtract_1, null, 1);
				armor_diff = armor_diff + 1;
			}
			while(armor_diff <= -0.1) {
				UnitBehaviorAdd(current, behav_armor_subtract_p1, null, 1);
				armor_diff = armor_diff + 0.1;
			}
		}

		if( StringCase( StringWord( libwyv_player[EventPlayer()].chat_msg, 1 ), false ) == "@shieldsarmor" ) {
			libwyv_unit_cache_update(UnitGroupLoopCurrent(), "@shieldsarmor", libwyv_player[EventPlayer()].chat_msg);
		}
		else { // using @armor
			libwyv_unit_cache_update(UnitGroupLoopCurrent(), "@armor", libwyv_player[EventPlayer()].chat_msg);
		}

		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

// libwyv_command_weaponspeed
// =====================
// Changes the weapon speed of a unit (local change)
// Because behaviors can only apply a weapon speed multiplier,
// to get target weapon speed we use formula
// W : original weapon speed
// Y : target weapon speed
// X : behavior stack, each behavior .9 or 1.1 weapon speed multiplier
// If Y > W : W(1.1)^X = Y
// If Y < W : W(0.9)^X = Y
// So we require stack X given by (floored to an int):
// If Y > W : X = log(Y/W)/log(1.1)
// If Y < W : X = log(Y/W)/log(0.9)
bool libwyv_command_weaponspeed(bool testConds, bool runActions) {
	unitgroup g = libwyv_player[EventPlayer()].context;
	fixed speed = StringToFixed( StringWord( libwyv_player[EventPlayer()].chat_msg, 2 ) );
	fixed ratio = 0;
	int stack_required;
	string weapon;
	unit current;

	if(speed > 15) {
		speed = 15;
	}
	if(speed <= 0.1) {
		speed = 0.1;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		current = UnitGroupLoopCurrent();
		weapon = UnitWeaponGet(current, 1);
		if(weapon != "") {
			ratio = StringToFixed(CatalogFieldValueGet(c_gameCatalogWeapon, weapon, "Period", UnitGetOwner(current))) / speed;
		}
		else {
			ratio = speed;
		}

		UnitBehaviorRemove(current, LIBWYV_BEHAVIOR_WEAPONSPEED_MULT_P9, -1);
		UnitBehaviorRemove(current, LIBWYV_BEHAVIOR_WEAPONSPEED_MULT_1P1, -1);

		if(ratio > 1) { // apply 1.1 multiplier
			stack_required = FixedToInt( Log2(ratio)/Log2(1.1) );
			if( stack_required > 100 ) {
				stack_required = 100;
			}
			UnitBehaviorAdd(current, LIBWYV_BEHAVIOR_WEAPONSPEED_MULT_1P1, null, stack_required);
		}
		else if( ratio < 1) { // ratio < 1: apply .9 multiplier
			stack_required = FixedToInt( Log2(ratio)/Log2(0.9) );
			if( stack_required > 100 ) {
				stack_required = 100;
			}
			UnitBehaviorAdd(current, LIBWYV_BEHAVIOR_WEAPONSPEED_MULT_P9, null, stack_required);
		}

		libwyv_unit_cache_update(UnitGroupLoopCurrent(), "@weaponspeed", libwyv_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

// libwyv_command_weaponspeedall
// ====================
// sets global weaponspeed for weapons on a unit
// (by changing the catalog weaponspeed value)
bool libwyv_command_weaponspeedall(bool testConds, bool runActions) {
	unitgroup g = libwyv_player[EventPlayer()].context;
	fixed speed = StringToFixed( StringWord( libwyv_player[EventPlayer()].chat_msg, 2 ) );
	int index;
	string weapon;
	unit current;

	if(speed > 15) {
		speed = 15;
	}
	if(speed <= 0.1) {
		speed = 0.1;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		current = UnitGroupLoopCurrent();
		index = UnitWeaponCount(current);
		while(index != 0) {
			weapon = UnitWeaponGet(current, 1);
			CatalogFieldValueSet(c_gameCatalogWeapon, UnitWeaponGet(current, index),
				"Period", UnitGetOwner(current), FixedToString(speed, -1));
			index -= 1;
		}

		UnitBehaviorRemove(current, LIBWYV_BEHAVIOR_WEAPONSPEED_MULT_P9, -1);
		UnitBehaviorRemove(current, LIBWYV_BEHAVIOR_WEAPONSPEED_MULT_1P1, -1);

		libwyv_unit_cache_update(UnitGroupLoopCurrent(), "@weaponspeedall", libwyv_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

// libwyv_command_subtitle
// =================
// sets a unit's subtitle (underneath a unit name)
bool libwyv_command_subtitle(bool testConds, bool runActions) {
	string val = libwyv_player[EventPlayer()].chat_msg;
	unitgroup g = libwyv_player[EventPlayer()].context;
	val = StringSub( val, StringFind(val, " ", c_stringCase)+1, StringLength(val)); // The remainder of the chat message.

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		CatalogFieldValueSet(c_gameCatalogUnit, UnitGetType(UnitGroupLoopCurrent()), "Subtitle", UnitGetOwner(UnitGroupLoopCurrent()), val);
		libwyv_unit_cache_update(UnitGroupLoopCurrent(), "@subtitle", libwyv_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

// libwyv_command_tooltip
// =====================
// sets a units tooltip, either the main tip or subtip
// (note: this is only visible to OTHER players)
bool libwyv_command_tooltip(bool testConds, bool runActions) {
	unitgroup g = libwyv_player[EventPlayer()].context;
	string description;
	bool subtip = false;

	if(StringWord( libwyv_player[EventPlayer()].chat_msg, 2) == "") {
		return true;
	}

	if(StringEqual(StringWord( libwyv_player[EventPlayer()].chat_msg, 2),"sub",c_stringNoCase)) {
		description = StringSub( libwyv_player[EventPlayer()].chat_msg, StringLength(StringWord( libwyv_player[EventPlayer()].chat_msg, 1)) + 2, StringLength(libwyv_player[EventPlayer()].chat_msg));
		description = StringSub( description, StringLength(StringWord( description, 1)) + 2, StringLength(description));

		subtip = true;
	}
	else {
		description = StringSub( libwyv_player[EventPlayer()].chat_msg, StringLength(StringWord( libwyv_player[EventPlayer()].chat_msg, 1)) + 2, StringLength(libwyv_player[EventPlayer()].chat_msg));
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		if(subtip) {
			UnitSetInfoSubTip(UnitGroupLoopCurrent(), StringToText(description));
		}
		else {
			UnitSetInfoTip(UnitGroupLoopCurrent(), StringToText(description));
		}
		libwyv_unit_cache_update(UnitGroupLoopCurrent(), "@tooltip", libwyv_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

// libwyv_command_copy
// ===============
// copies selected units:
// - stats, behaviors, orders, weapons
// - visuals (by parsing commands from source cache)
bool libwyv_command_copy(bool testConds, bool runActions) {
	unitgroup g = libwyv_player[EventPlayer()].context;
	unitgroup created = UnitGroupEmpty();
	unit source;
	unitgroup targets;
	unit target;
	int i;
	int cache;
	string source_unit_id;

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		source = UnitGroupLoopCurrent();
		targets = UnitCreate(1, UnitGetType(source), c_unitCreateIgnorePlacement, UnitGetOwner(source), libwyv_player[EventPlayer()].mouse_position, UnitGetFacing(source));
		target = UnitGroupUnit(targets, 1);

		//set the unit's id on data table
		libwyv_unit_set_id(target);
		UnitSetCustomValue(target, LIBWYV_UNIT_INDEX_CACHE_COUNT, 1);

		// add to created unit group
		UnitGroupAdd(created, target);

		UnitSetHeight(target, UnitGetHeight(source), 0);
		UnitSetState(target, c_unitStateInvulnerable,
			UnitTestState(source, c_unitStateInvulnerable));
		UnitSetState(target, c_unitStatePaused,
			UnitTestState(source, c_unitStatePaused));
		UnitSetState(target, c_unitStateHidden,
			UnitTestState(source, c_unitStateHidden));
		UnitSetState(target, c_unitStateHighlightable,
			UnitTestState(source, c_unitStateHighlightable));
		UnitSetState(target, c_unitStateIgnoreTerrainZ,
			UnitTestState(source, c_unitStateIgnoreTerrainZ));
		UnitSetState(target, c_unitStateFidget,
			UnitTestState(source, c_unitStateFidget));
		UnitSetState(target, c_unitStateTargetable,
			UnitTestState(source, c_unitStateTargetable));
		UnitSetState(target, c_unitStateTooltipable,
			UnitTestState(source, c_unitStateTooltipable));
		UnitSetState(target, c_unitStateCursorable,
			UnitTestState(source, c_unitStateCursorable));
		UnitSetState(target, c_unitStateHighlighted,
			UnitTestState(source, c_unitStateHighlighted));
		UnitSetState(target, c_unitStateUsingSupply,
			UnitTestState(source, c_unitStateUsingSupply));
		UnitSetPropertyFixed(target, c_unitPropLifeMax,
			UnitGetPropertyFixed(source, c_unitPropLifeMax, true));
		UnitSetPropertyFixed(target, c_unitPropLife,
			UnitGetPropertyFixed(source, c_unitPropLife, true));
		UnitSetPropertyFixed(target, c_unitPropLifeRegen,
			UnitGetPropertyFixed(source, c_unitPropLifeRegen, true));
		UnitSetPropertyFixed(target, c_unitPropEnergyMax,
			UnitGetPropertyFixed(source, c_unitPropEnergyMax, true));
		UnitSetPropertyFixed(target, c_unitPropEnergy,
			UnitGetPropertyFixed(source, c_unitPropEnergy, true));
		UnitSetPropertyFixed(target, c_unitPropEnergyRegen,
			UnitGetPropertyFixed(source, c_unitPropEnergyRegen, true));
		UnitSetPropertyFixed(target, c_unitPropShieldsMax,
			UnitGetPropertyFixed(source, c_unitPropShieldsMax, true));
		UnitSetPropertyFixed(target, c_unitPropShields,
			UnitGetPropertyFixed(source, c_unitPropShields, true));
		UnitSetPropertyFixed(target, c_unitPropShieldsRegen,
			UnitGetPropertyFixed(source, c_unitPropShieldsRegen, true));
		UnitSetPropertyFixed(target, c_unitPropKills,
			UnitGetPropertyFixed(source, c_unitPropKills, true));
		UnitSetPropertyFixed(target, c_unitPropMovementSpeed,
			UnitGetPropertyFixed(source, c_unitPropMovementSpeed, true));
		UnitSetPropertyFixed(target, c_unitPropResources,
			UnitGetPropertyFixed(source, c_unitPropResources, true));

		// Skipping implementing ability commands and their charges.
		// Skipping implementing the cargo contained in a unit
		// Skipping implementing unit magazines
		// Skipping implementing unit queues

		i = UnitBehaviorCountAll(source);
		while(i != 0) {
			UnitBehaviorAdd(target, UnitBehaviorGet(source, i), null,
				UnitBehaviorCount(source, UnitBehaviorGet(source, i)));
			UnitBehaviorSetDuration(target, UnitBehaviorGet(source, i),
				UnitBehaviorDuration(source, UnitBehaviorGet(source, i)));
			i -= 1;
		}

		i = 1;
		while(i <= UnitOrderCount(source)) {
			UnitIssueOrder(target, UnitOrder(source, i), c_orderQueueAddToEnd);
			i += 1;
		}

		i = UnitWeaponCount(target);
		while(i != 0) {
			UnitWeaponRemove(target, UnitWeaponGet(target, 1));
			i -= 1;
		}

		i = UnitWeaponCount(source);
		while(i != 0) {
			// Does not copy turrets!
			UnitWeaponAdd(target, UnitWeaponGet(source, i), null);
			i -= 1;
		}

		// Skipping implementing setname duplications
		// Copy the visuals via cache
		source_unit_id = FixedToString(UnitGetCustomValue(source, LIBWYV_UNIT_INDEX_ID), 0);
		cache = 1;
		while( DataTableValueExists(true, source_unit_id + "." + IntToString(cache)) ) {
			libwyv_chat_parse(DataTableGetString(true, source_unit_id + "." + IntToString(cache)), EventPlayer(), targets);
			cache += 1;
		}

		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	libwyv_player[EventPlayer()].context = created;

	return true;
}

// libwyv_command_effect
// ===============
// creates an effect at target units or at a point
bool libwyv_command_effect(bool testConds, bool runActions) {
	unitgroup g = libwyv_player[EventPlayer()].context;
	string effect = StringWord( libwyv_player[EventPlayer()].chat_msg, 2 );

	effect = libwyv_catalog_get(c_gameCatalogEffect, effect);
	if(effect == null) {
		libwyv_print_error(EventPlayer(), "<c val=\"ff0000\">Unable to create effect</c>: No such effect exists.");
		return true;
	}

	if( UnitGroupCount(g, c_unitCountAll) != 0 ) {
		UnitGroupLoopBegin(g);
		while(!UnitGroupLoopDone()) {
			if( libNtve_gf_PlayerCanCreateEffectOnUnit(EventPlayer(), effect, UnitGroupLoopCurrent()) ) {
				PlayerCreateEffectUnit(EventPlayer(), effect, UnitGroupLoopCurrent());
				libwyv_unit_cache_update(UnitGroupLoopCurrent(), "@effect", libwyv_player[EventPlayer()].chat_msg);
			}
			else {
				libwyv_print_error(EventPlayer(), "<c val=\"ff0000\">Unable to create the effect.</c>");
			}
			UnitGroupLoopStep();
		}
		UnitGroupLoopEnd();
	}
	else {
		if( libNtve_gf_PlayerCanCreateEffectAtPoint(EventPlayer(), StringWord(EventChatMessage(false), 2), libwyv_player[EventPlayer()].mouse_position) ) {
			PlayerCreateEffectPoint(EventPlayer(), effect, libwyv_player[EventPlayer()].mouse_position);
		}
		else {
			libwyv_print_error(EventPlayer(), "<c val=\"ff0000\">Unable to create the effect.</c>");
		}
	}

	return true;
}

// libwyv_command_kills
// ==============
// sets the number of kills on a unit
// (only useful for changing unit kill rank)
bool libwyv_command_kills(bool testConds, bool runActions) {
	unitgroup g = libwyv_player[EventPlayer()].context;
	fixed val = StringToFixed( StringWord( libwyv_player[EventPlayer()].chat_msg, 2 ) );

	if( val <= 0 ) { // Bad input!
		return true;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropKills, val );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

// libwyv_command_level
// ===============
// sets a unit's level (level range between 0 - 20)
// (if a unit does not have veterancy behavior,
// it is added before setting level)
bool libwyv_command_level(bool testConds, bool runActions) {
	unitgroup g = libwyv_player[EventPlayer()].context;
	int val = StringToInt( StringWord( libwyv_player[EventPlayer()].chat_msg, 2 ) );

	if( val <= 0 || val > 20 ) { // Bad input!
		return true;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
        // Give the level behavior to the unit so that it can level.
        if( !UnitHasBehavior(UnitGroupLoopCurrent(), LIBWYV_BEHAVIOR_LEVELS) ) {
            UnitBehaviorAdd( UnitGroupLoopCurrent(), LIBWYV_BEHAVIOR_LEVELS, UnitGroupLoopCurrent(), 1);
        }

        if( UnitLevel(UnitGroupLoopCurrent()) == val ) {
            UnitGroupLoopStep();
            continue;
        }

        UnitSetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropLevel, val);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

// libwyv_command_label
// =================
// creates and attaches a text tag to unit
// labels are destroyed when units removed/killed
bool libwyv_command_label(bool testConds, bool runActions) {
	int tag_id;
	bool remove_tag = false;
	unitgroup g = libwyv_player[EventPlayer()].context;
	string label = libwyv_player[EventPlayer()].chat_msg;
	label = StringSub( label, StringFind(label, " ", c_stringCase) + 1, StringLength(label)); // The remainder of the chat message.

	if( StringLength(label) > 512 ) {
		libwyv_print_error(EventPlayer(), "Your label length is too long.");
		return true;
	}

	if( label == "" ) {
		remove_tag = true;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		if( remove_tag || UnitGetCustomValue(UnitGroupLoopCurrent(), LIBWYV_UNIT_INDEX_TEXTTAG) != 0.0 ) {
			tag_id = FixedToInt( UnitGetCustomValue(UnitGroupLoopCurrent(), LIBWYV_UNIT_INDEX_TEXTTAG) );
			TextTagDestroy(tag_id);
			UnitSetCustomValue( UnitGroupLoopCurrent(), LIBWYV_UNIT_INDEX_TEXTTAG, 0.0 );
		}

		if( !remove_tag ) {
			tag_id = TextTagCreate( TextWithColor( StringToText(label), ColorFromIndex( PlayerGetColorIndex(EventPlayer(), false), c_teamColorDiffuse ) ),
									40, UnitGetPosition(UnitGroupLoopCurrent()), 1.0, true, true, PlayerGroupAll() );
			TextTagSetTextShadow(tag_id, true);
			TextTagAttachToUnit(tag_id, UnitGroupLoopCurrent(), 1.0);

			UnitSetCustomValue(UnitGroupLoopCurrent(), LIBWYV_UNIT_INDEX_TEXTTAG, IntToFixed(tag_id));
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

// libwyv_command_radius
// ====================
// adjusts a unit's collision radius
bool libwyv_command_radius(bool testConds, bool runActions) {
	string val = StringWord( libwyv_player[EventPlayer()].chat_msg, 2 );
	fixed radius;
	unitgroup g = libwyv_player[EventPlayer()].context;

	if(val == "") {
		libwyv_print_error(EventPlayer(), "Usage: @radius collision_radius[%]");
	}
	else if(StringContains(val, "%", c_stringEnd, c_stringCase)) {
		radius = StringToFixed(StringSub(val, 1, StringLength(val) - 1));
		radius = radius / 100;

		UnitGroupLoopBegin(g);
		while(!UnitGroupLoopDone()) {
			val = CatalogFieldValueGet(c_gameCatalogUnit, UnitGetType(UnitGroupLoopCurrent()), "Radius", UnitGetOwner(UnitGroupLoopCurrent()));
			val = FixedToString(StringToFixed(val) * radius, 8);
			CatalogFieldValueSet(c_gameCatalogUnit, UnitGetType(UnitGroupLoopCurrent()), "Radius", UnitGetOwner(UnitGroupLoopCurrent()), val);

			val = CatalogFieldValueGet(c_gameCatalogUnit, UnitGetType(UnitGroupLoopCurrent()), "InnerRadius", UnitGetOwner(UnitGroupLoopCurrent()));
			val = FixedToString(StringToFixed(val) * radius, 8);
			CatalogFieldValueSet(c_gameCatalogUnit, UnitGetType(UnitGroupLoopCurrent()), "InnerRadius", UnitGetOwner(UnitGroupLoopCurrent()), val);
			UnitGroupLoopStep();
		}
		UnitGroupLoopEnd();
	}
	else {
		UnitGroupLoopBegin(g);
		while(!UnitGroupLoopDone()) {
			CatalogFieldValueSet(c_gameCatalogUnit, UnitGetType(UnitGroupLoopCurrent()), "Radius", UnitGetOwner(UnitGroupLoopCurrent()), val);
			CatalogFieldValueSet(c_gameCatalogUnit, UnitGetType(UnitGroupLoopCurrent()), "InnerRadius", UnitGetOwner(UnitGroupLoopCurrent()), val);
			UnitGroupLoopStep();
		}
		UnitGroupLoopEnd();
	}

	return true;
}

// libwyv_command_state
// ====================
// allows a user to adjust various default unit status settings:
// these are settings built-in to the game unit type itself.
// each setting can either be on (true) or off (false).
//        syntax: @state [state-name] [on/off]
// for [on/off], any input that isnt "on" is parsed as "off" (false)
bool libwyv_command_state(bool testConds, bool runActions) {
	string param = StringCase( StringWord( libwyv_player[EventPlayer()].chat_msg, 2 ), false );
	int state;
	bool status = false;
	unitgroup g = libwyv_player[EventPlayer()].context;

	// get 1st parameter as the state option
	if( param == "fidget" ) {
		state = c_unitStateFidget;
	} else if( param == "highlightable" ) {
		state = c_unitStateHighlightable;
	} else if( param == "highlighted" ) {
		state = c_unitStateHighlighted;
	} else if( param == "ignoreterrainheight" ) {
		state = c_unitStateIgnoreTerrainZ;
	} else if( param == "invulnerable" ) {
		state = c_unitStateInvulnerable;
	} else if( param == "hidden" ) {
		state = c_unitStateHidden;
	} else if( param == "paused" ) {
		state = c_unitStatePaused;
	} else if( param == "selectable" ) {
		state = c_unitStateSelectable;
	} else if( param == "statusbar" ) {
		state = c_unitStateStatusBar;
	} else if( param == "targetable" ) {
		state = c_unitStateTargetable;
	} else if( param == "tooltips" ) {
		state = c_unitStateTooltipable;
	} else if( param == "cursor" ) {
		state = c_unitStateCursorable;
	} else if( param == "movable" ) {
		state = c_unitStateMoveSuppressed;
	} else if( param == "turnable" ) {
		state = c_unitStateTurnSuppressed;
	} else if( param == "usessupply" ) {
		state = c_unitStateUsingSupply;
	} else {
		libwyv_print_error(EventPlayer(), "Usage: @radius [state] [on/off]\n" +
							"States: fidget, highlightable, highlighted, ignoreterrainheight, invulnerable, hidden, paused, selectable, statusbar, targetable, tooltips, cursor, movable, turnable, usessupply");
		return false;
	}

	// status as 2nd parameter
	if( StringCase( StringWord( libwyv_player[EventPlayer()].chat_msg, 3 ), false ) == "on" ) {
		status = true;
	}

	libwyv_print(PlayerGroupSingle(EventPlayer()), "Setting state " + param + ": " + libNtve_gf_ConvertBooleanToString(status));

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		UnitSetState( UnitGroupLoopCurrent(), state, status );
		libwyv_unit_cache_update(UnitGroupLoopCurrent(), "@state", libwyv_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}
