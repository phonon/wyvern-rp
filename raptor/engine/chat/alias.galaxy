//=========================================================
//		Raptor Roleplaying Engine
//		Copyright (c) 2014 , Xethyr.407 [NA] / @90-proof
//=========================================================
// This software is distributed under the MIT License:
// <http://opensource.org/licenses/MIT>
//=========================================================

const int LIBRPTR_ALIAS_MAX_DEPTH = 10;	// max depth of recursive alias replacing (prevent infinite aliasing)
const string LIBRPTR_BANK_SECTION_ALIAS = "alias";

// librptr_alias_command_redirect
// ===================
// gets "alias ..." command from parser, redirects to function
bool librptr_alias_command_redirect(string command, int player) {
	string subcommand = StringWord(command, 2);
	string alias = "";
	string content = librptr_player[player].chat_msg;
	
	if( StringEqual(subcommand, "create", c_stringNoCase) ) { 
		alias = StringWord(command, 3);
		
		// remove "alias" and "create" and the alias from content string
		content = StringReplaceWord(content, "alias", "", 1, c_stringNoCase);
		content = StringReplaceWord(content, "create", "", 1, c_stringNoCase);
		content = librptr_string_trim( StringSub(content, StringFind(content, alias, c_stringNoCase) + StringLength(alias) + 1, StringLength(content)) );
		
		if( content != "" ) { 
			librptr_bank_create(LIBRPTR_BANK_SECTION_ALIAS, alias, content, player);
			librptr_print_success("ALIAS CREATED: " + alias + "\n" + "[\'" + content + "\']", player);
		}
		else {
			librptr_print_error("ALIAS CANNOT BE EMPTY", player);
		}
		
		return true;
	}
	else if( StringEqual(subcommand, "remove", c_stringNoCase) ) {
		alias = StringWord(command, 3);
		if( BankKeyExists(librptr_player[player].bank_storage, LIBRPTR_BANK_SECTION_ALIAS, alias) ) {
			librptr_bank_remove(LIBRPTR_BANK_SECTION_ALIAS, alias, player);
			librptr_print_success("ALIAS REMOVED: " + alias, player);
		}
		else {
			librptr_print_error("ALIAS " + alias + " DOES NOT EXIST", player);
		}
	}
	else if( StringEqual(subcommand, "removeall", c_stringNoCase) ) {
		librptr_bank_section_remove_all(LIBRPTR_BANK_SECTION_ALIAS, player);
		librptr_print_success("ALL ALIASES REMOVED", player);
	}
	else if( StringEqual(subcommand, "list", c_stringNoCase) ) {
		librptr_bank_section_dump(LIBRPTR_BANK_SECTION_ALIAS, player);
	}
	else if( StringEqual(subcommand, "print", c_stringNoCase) ) {
		librptr_bank_key_content_dump(LIBRPTR_BANK_SECTION_ALIAS, StringWord(command, 3), player);
	}
	else if( BankKeyExists(librptr_player[player].bank_storage, LIBRPTR_BANK_SECTION_ALIAS, subcommand) ) {
		librptr_bank_key_content_dump(LIBRPTR_BANK_SECTION_ALIAS, subcommand, player);
	}
	else {
		librptr_print_error("INVALID ALIAS COMMAND", player);
	}
	
	return false;
}

// librptr_alias_sub
// ===================
// recursively find and replace aliases in a given string
string librptr_alias_sub(string msg, int player, int recursion_depth) {
	string alias = StringWord(msg, 1);
	string subbed = "";
	int i = 1;
	
	if( recursion_depth > LIBRPTR_ALIAS_MAX_DEPTH ) {
		return msg;
	}
	
	while( alias != "" ) {
		if( BankKeyExists( librptr_player[player].bank_storage, LIBRPTR_BANK_SECTION_ALIAS, alias ) ) {
			subbed = subbed + " " + librptr_alias_sub(BankValueGetAsString(librptr_player[player].bank_storage, LIBRPTR_BANK_SECTION_ALIAS, alias), player, recursion_depth + 1);
		}
		else {
			subbed = subbed + " " + alias;
		}
		
		i += 1;
		alias = StringWord(msg, i);
	}

	// remove extra front end " " for return
	return StringSub(subbed, 2, StringLength(subbed));
}
