//=========================================================
//		Raptor Roleplaying Engine
//		Copyright (c) 2014 , Xethyr.407 [NA] / @90-proof
//=========================================================
// This software is distributed under the MIT License:
// <http://opensource.org/licenses/MIT>
//=========================================================

const int LIBRPTR_ALIAS_MAX_DEPTH = 10;	// max depth of recursive alias replacing (prevent infinite aliasing)
const string LIBRPTR_BANK_SECTION_ALIAS = "alias";

// librptr_alias_ (bank functions)
// =========================================
// creates, removes alias value from player bank
// !!! BankSave required to ensure the changes persist
void librptr_alias_create(string alias, string content, int player) {
	BankValueSetFromString(librptr_player[player].bank_storage, LIBRPTR_BANK_SECTION_ALIAS, alias, content);
	BankSave(librptr_player[player].bank_storage);
	librptr_print_success("ALIAS CREATED: " + alias + "\n" + "[" + content + "]", player);
}

void librptr_alias_remove(string alias, int player) {
	BankKeyRemove(librptr_player[player].bank_storage, LIBRPTR_BANK_SECTION_ALIAS, alias);
	BankSave(librptr_player[player].bank_storage);
	librptr_print_success("ALIAS REMOVED: " + alias, player);
}

void librptr_alias_remove_all(int player) {
	BankSectionRemove(librptr_player[player].bank_storage, LIBRPTR_BANK_SECTION_ALIAS);
	BankSave(librptr_player[player].bank_storage);
	librptr_print_success("ALL ALIASES REMOVED", player);
}

// librptr_alias_content_dump
// =================
// prints out content of an alias
void librptr_alias_content_dump(string alias, int player) {
	if( BankKeyExists(librptr_player[player].bank_storage, LIBRPTR_BANK_SECTION_ALIAS, alias) ) {
		librptr_print_output("ALIAS: " + alias, player);
		librptr_print_output("CONTENT: " + BankValueGetAsString(librptr_player[player].bank_storage, LIBRPTR_BANK_SECTION_ALIAS, alias), player);
	}
	else {
		librptr_print_error("ALIAS " + alias + " DOES NOT EXIST", player);
	}
}

// librptr_alias_content_dump
// =================
// lists all of a player's aliases
void librptr_alias_dump(int player) {
	int count = BankKeyCount(librptr_player[player].bank_storage, LIBRPTR_BANK_SECTION_ALIAS);
	string aliases = "[";
	
	if( count ) {
		while(count) {
			aliases = aliases + "\'" + BankKeyName(librptr_player[player].bank_storage, LIBRPTR_BANK_SECTION_ALIAS, count - 1) + "\',";
			count -= 1;
		}
		// remove extra ','
		librptr_print_output( StringSub(aliases, 1, 1), player );
		aliases = StringSub(aliases, 1, StringLength(aliases) - 1) + "]";
		librptr_print_output( "Aliases:\n" + aliases, player);
	}
	else {
		librptr_print_output("You have no aliases", player);
	}
}

// librptr_alias_command_redirect
// ===================
// gets "alias ..." command from parser, redirects to function
bool librptr_alias_command_redirect(string command, int player) {
	string subcommand = StringWord(command, 2);
	string alias = "";
	string content = "";
	
	if( StringEqual(subcommand, "create", c_stringNoCase) ) { 
		alias = StringWord(command, 3);
		librptr_print_output("current chat message: " + librptr_player[player].chat_msg, player);
		content = librptr_string_trim( StringSub(librptr_player[player].chat_msg, StringLength("alias create " + alias) + 1, StringLength(librptr_player[player].chat_msg)) );
		if( content != "" ) {
			librptr_alias_create(alias, content, player);
		}
		else {
			librptr_print_error("ALIAS CANNOT BE EMPTY", player);
		}
		
		return true;
	}
	else if( StringEqual(subcommand, "remove", c_stringNoCase) ) {
		alias = StringWord(command, 3);
		if( BankKeyExists(librptr_player[player].bank_storage, LIBRPTR_BANK_SECTION_ALIAS, alias) ) {
			librptr_alias_remove(alias, player);
		}
		else {
			librptr_print_error("ALIAS " + alias + " DOES NOT EXIST", player);
		}
	}
	else if( StringEqual(subcommand, "removeall", c_stringNoCase) ) {
		librptr_alias_remove_all(player);
	}
	else if( StringEqual(subcommand, "list", c_stringNoCase) ) {
		librptr_alias_dump(player);
	}
	else if( StringEqual(subcommand, "print", c_stringNoCase) ) {
		librptr_alias_content_dump(StringWord(command, 3), player);
	}
	else if( BankKeyExists(librptr_player[player].bank_storage, LIBRPTR_BANK_SECTION_ALIAS, subcommand) ) {
		librptr_alias_content_dump(subcommand, player);
	}
	else {
		librptr_print_error("INVALID ALIAS COMMAND", player);
	}
	
	return false;
}

// librptr_alias_sub
// ===================
// recursively find and replace aliases in a given string
string librptr_alias_sub(string msg, int player, int recursion_depth) {
	string alias = StringWord(msg, 1);
	string subbed = "";
	int i = 1;
	
	if( recursion_depth > LIBRPTR_ALIAS_MAX_DEPTH ) {
		return msg;
	}
	
	while( alias != "" ) {
		if( BankKeyExists( librptr_player[player].bank_storage, LIBRPTR_BANK_SECTION_ALIAS, alias ) ) {
			subbed = subbed + " " + librptr_alias_sub(BankValueGetAsString(librptr_player[player].bank_storage, LIBRPTR_BANK_SECTION_ALIAS, alias), player, recursion_depth + 1);
		}
		else {
			subbed = subbed + " " + alias;
		}
		
		i += 1;
		alias = StringWord(msg, i);
	}

	// remove extra front end " " for return
	return StringSub(subbed, 2, StringLength(subbed));
}
