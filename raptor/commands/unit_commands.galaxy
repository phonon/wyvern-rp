//=========================================================
//		Raptor Roleplaying Engine
//		Copyright (c) 2014 , Xethyr.407 [NA] / @90-proof
//=========================================================
// This software is distributed under the MIT License:
// <http://opensource.org/licenses/MIT>
//=========================================================

// librptr_command_kill
// ====================
// kills units in player unitgroup context
bool librptr_command_kill(bool testConds, bool runActions) {
	UnitGroupLoopBegin(librptr_player[EventPlayer()].context);
	while(!UnitGroupLoopDone()) {
		UnitKill( UnitGroupLoopCurrent() );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

// librptr_command_remove
// ====================
// removes units in player unitgroup context
bool librptr_command_remove(bool testConds, bool runActions) {
	UnitGroupLoopBegin(librptr_player[EventPlayer()].context);
	while(!UnitGroupLoopDone()) {
		UnitRemove(UnitGroupLoopCurrent());
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

// librptr_command_removearea
// =====================
// removes unit in a radius around mouse position
bool librptr_command_removearea(bool testConds, bool runActions) {
	unitgroup g;
	fixed radius = StringToFixed( StringWord( librptr_player[EventPlayer()].chat_msg, 2 ));
	if(radius == 0.0) {
		radius = 5.0;
	}

	g = UnitGroup( null, c_playerAny, RegionCircle( librptr_player[EventPlayer()].mouse_position, radius), null, 0 );
	g = librptr_enforce_unit_permissions(g, EventPlayer());

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		UnitRemove( UnitGroupLoopCurrent() );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	
	libNtve_gf_RemoveDeathModelsinRegion( RegionCircle( librptr_player[EventPlayer()].mouse_position, radius) );

	return true;
}

// librptr_command_cache
// ===================
// displays unit command cache info or values
bool librptr_command_cache(bool testConds, bool runActions) {
	string cache;
	string unit_caches;
	unitgroup g = librptr_player[EventPlayer()].context;
	
	cache = StringWord(librptr_player[EventPlayer()].chat_msg, 2);
	
	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		if(StringToInt(cache) == 0) { //display number of caches
			if(UnitGetCustomValue(UnitGroupLoopCurrent(), LIBRPTR_UNIT_INDEX_CACHE_COUNT) == 1 && !DataTableValueExists(true, FixedToString(UnitGetCustomValue(UnitGroupLoopCurrent(), LIBRPTR_UNIT_INDEX_ID), 0) + ".1")) {
				unit_caches = "0";
			}
			else {
				unit_caches = FixedToString(UnitGetCustomValue(UnitGroupLoopCurrent(), LIBRPTR_UNIT_INDEX_CACHE_COUNT), 0);
			}
			librptr_print_output("Unit " + UnitGetType(UnitGroupLoopCurrent()) + " has " + unit_caches + " command caches (type \"@cache #\" to view a cache)", EventPlayer());
		}
		else {
			if(DataTableValueExists(true, FixedToString(UnitGetCustomValue(UnitGroupLoopCurrent(), LIBRPTR_UNIT_INDEX_ID), 0) + "." + cache)) {
				librptr_print_output("Unit " + UnitGetType(UnitGroupLoopCurrent()) + " cache " + cache + ":<n/>" + DataTableGetString(true, FixedToString(UnitGetCustomValue(UnitGroupLoopCurrent(), LIBRPTR_UNIT_INDEX_ID), 0) + "." + cache), EventPlayer());
			}
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();	
	return true;
}

// librptr_command_give
// =================
// gives another player units 
bool librptr_command_give(bool testConds, bool runActions) {
	unitgroup g = librptr_player[EventPlayer()].context;
	int new_owner = librptr_color_to_player( StringWord(librptr_player[EventPlayer()].chat_msg, 2) ); 
	
	if(new_owner == -1) { // invalid entry by user
		return true;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		UnitSetOwner( UnitGroupLoopCurrent(), new_owner, true );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

// librptr_command_renameall
// ===================
// renames all units (by replacing unit catalog name entry)
bool librptr_command_renameall(bool testConds, bool runActions) {
	string val;
	unitgroup g = librptr_player[EventPlayer()].context;
	val = librptr_player[EventPlayer()].chat_msg;
	val = StringSub( val, StringFind(val, " ", c_stringCase)+1, StringLength(val)); // The remainder of the chat message.	

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		CatalogFieldValueSet(c_gameCatalogUnit, UnitGetType(UnitGroupLoopCurrent()), "Name", UnitGetOwner(UnitGroupLoopCurrent()), val);
		librptr_unit_cache_update(UnitGroupLoopCurrent(), "@renameall", librptr_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

bool librptr_command_addbehavior(bool testConds, bool runActions) {
	string val;
	int x;
	int i;
	string s;
	unitgroup g = librptr_player[EventPlayer()].context;
	val = StringWord( librptr_player[EventPlayer()].chat_msg, 2 );
	
	// get full behavior name from catalog
	val = librptr_catalog_get(c_gameCatalogBehavior, val);
	if(val == null) {
		librptr_print_error("<c val=\"ff0000\">Unable to add behavior</c>: No such behavior exists.", EventPlayer());
		return true;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		UnitBehaviorAdd( UnitGroupLoopCurrent(), val, UnitGroupLoopCurrent(), 1 );
		librptr_unit_cache_update(UnitGroupLoopCurrent(), "@addbehavior", librptr_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	
	return true;
}

bool librptr_command_removebehavior(bool testConds, bool runActions) {
	string val;
	string s;
	int i;
	int x;
	unitgroup g = librptr_player[EventPlayer()].context;
	val = StringWord( librptr_player[EventPlayer()].chat_msg, 2 );

	// Check for an invalid behavior name, and attempt to compensate.
	val = librptr_catalog_get(c_gameCatalogBehavior, val);
	if(val == null) {
		librptr_print_error("<c val=\"ff0000\">Unable to remove behavior</c>: No such behavior exists.", EventPlayer());
		return true;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		UnitBehaviorRemove( UnitGroupLoopCurrent(), val, 1 );
		librptr_unit_cache_update(UnitGroupLoopCurrent(), "@removebehavior", librptr_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	
	return true;
}

bool librptr_command_addweapon(bool testConds, bool runActions) {
	string weapon;
	string turret;
	int i;
	int x;
	string s;
	unitgroup g = librptr_player[EventPlayer()].context;
	weapon = StringWord( librptr_player[EventPlayer()].chat_msg, 2 );
	turret = StringWord( librptr_player[EventPlayer()].chat_msg, 3 );
	
	if( turret == "" ) {
		turret = "CTurret";
	}

	weapon = librptr_catalog_get(c_gameCatalogWeapon, weapon);
	if( weapon == null || CatalogEntryScope(c_gameCatalogWeapon, weapon) == weapon) {
		librptr_print_error("<c val=\"ff0000\">Unable to add weapon</c>: No such weapon exists.", EventPlayer());		
		return true;
	}
	
	// if turret is not default, use catalog get on turet
	if( turret != "CTurret") {
		turret = librptr_catalog_get(c_gameCatalogTurret, turret);
		if( turret == null ) {
			librptr_print_error("<c val=\"ff0000\">Unable to add weapon</c>: No such turret exists.", EventPlayer());		
			return true;
		}
	}

	UnitGroupLoopBegin(g);
	while( !UnitGroupLoopDone() ) {
		UnitWeaponAdd( UnitGroupLoopCurrent(), weapon, turret );
		librptr_unit_cache_update(UnitGroupLoopCurrent(), "@addweapon", librptr_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

bool librptr_command_removeweapon(bool testConds, bool runActions) {
	string weapon;
	int i;
	int x;
	string s;
	unitgroup g = librptr_player[EventPlayer()].context;
	weapon = StringWord( librptr_player[EventPlayer()].chat_msg, 2 );

	weapon = librptr_catalog_get(c_gameCatalogWeapon, weapon);
	if ( weapon == null || CatalogEntryScope(c_gameCatalogWeapon, weapon) == weapon) {
		librptr_print_error("<c val=\"ff0000\">Unable to remove weapon</c>: No such weapon exists.", EventPlayer());		
		return true;
	}
	
	UnitGroupLoopBegin(g);
	while( !UnitGroupLoopDone() ) {
		UnitWeaponRemove( UnitGroupLoopCurrent(), weapon );
		librptr_unit_cache_update(UnitGroupLoopCurrent(), "@removeweapon", librptr_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	
	return true;
}

// librptr_command_life
// librptr_command_shields
// librptr_command_energy
// ===================
// sets units life, shields, or energy (absolute, adding, or percentage)
// e.g. syntax: @life 10, @life 10%, @life +10, @life +10%
bool librptr_command_life(bool testConds, bool runActions) {
	string param;
	fixed val;
	bool percent = false;
	unitgroup g = librptr_player[EventPlayer()].context;
	bool absolute = true;
	
	param = StringWord( librptr_player[EventPlayer()].chat_msg, 2 );

	if( StringContains(param, "%", c_stringEnd, c_stringCase) ) {
		percent = true;
		param = StringSub(param, 1, StringLength(param)-1);
	}
	if( StringContains(param, "+", c_stringBegin, c_stringCase) ) {
		absolute = false;
		param = StringSub(param, 2, StringLength(param));
	}
	
	val = StringToFixed(param);
	
	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		if(!absolute) {
			if(percent) {
				UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropLife, UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropLife, c_unitPropCurrent) + (UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropLifeMax, c_unitPropCurrent)*(val/100)) );
			}
			else {
				UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropLife, UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropLife, c_unitPropCurrent) + val );
			}
		}
		else {
			if(percent) {
				UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropLifePercent, val );
			}
			else {
				UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropLife, val );
			}
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

bool librptr_command_shields(bool testConds, bool runActions) {
	string param;
	fixed val;
	bool percent = false;
	unitgroup g = librptr_player[EventPlayer()].context;
	bool absolute = true;
	
	param = StringWord( librptr_player[EventPlayer()].chat_msg, 2 );

	if( StringContains(param, "%", c_stringEnd, c_stringCase) ) {
		percent = true;
		param = StringSub(param, 1, StringLength(param)-1);
	}
	if( StringContains(param, "+", c_stringBegin, c_stringCase) ) {
		absolute = false;
		param = StringSub(param, 2, StringLength(param));
	}
	
	val = StringToFixed(param);
	
	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		if(!absolute) {
			if(percent) {
				UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropShields, UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropShields, c_unitPropCurrent) + (UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropShieldsMax, c_unitPropCurrent)*(val/100)) );
			}
			else {
				UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropShields, UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropShields, c_unitPropCurrent) + val );
			}
		}
		else {
			if(percent) {
				UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropShieldsPercent, val );
			}
			else {
				UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropShields, val );
			}
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

bool librptr_command_energy(bool testConds, bool runActions) {
	string param;
	fixed val;
	bool percent = false;
	unitgroup g = librptr_player[EventPlayer()].context;
	bool absolute = true;
	
	param = StringWord( librptr_player[EventPlayer()].chat_msg, 2 );

	if( StringContains(param, "%", c_stringEnd, c_stringCase) ) {
		percent = true;
		param = StringSub(param, 1, StringLength(param)-1);
	}
	if( StringContains(param, "+", c_stringBegin, c_stringCase) ) {
		absolute = false;
		param = StringSub(param, 2, StringLength(param));
	}
	
	val = StringToFixed(param);
	
	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		if(!absolute) {
			if(percent) {
				UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropEnergy, UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropEnergy, c_unitPropCurrent) + (UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropEnergyMax, c_unitPropCurrent)*(val/100)) );
			}
			else {
				UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropEnergy, UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropEnergy, c_unitPropCurrent) + val );
			}
		}
		else {
			if(percent) {
				UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropEnergyPercent, val );
			}
			else {
				UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropEnergy, val );
			}
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

// librptr_command_maxlife
// librptr_command_maxshields
// librptr_command_maxenergy
// =====================
// sets a unit's maxlife, maxshields, or maxenergy
// can specify as either absolute, percentage, or added value
// e.g. syntax: @maxlife 10, @maxlife 10%, @maxlife +10%, @maxlife +10
bool librptr_command_maxlife(bool testConds, bool runActions) {
	string param;
	fixed val;
	bool percent = false;
	unitgroup g = librptr_player[EventPlayer()].context;
	bool absolute = true;
	
	param = StringWord( librptr_player[EventPlayer()].chat_msg, 2 );
	
	if( StringContains(param, "%", c_stringEnd, c_stringCase) ) {
		percent = true;
		param = StringSub(param, 1, StringLength(param)-1);
	}
	if( StringContains(param, "+", c_stringBegin, c_stringCase) ) {
		absolute = false;
		param = StringSub(param, 2, StringLength(param));
	}
	
	val = StringToFixed(param);

	if( val <= 0 && absolute) {
		return true;
	}
	
	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		if(!absolute) {
			if(percent) {
				val = UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropLifeMax, c_unitPropCurrent) + (UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropLifeMax, c_unitPropCurrent)*(val/100));
			}
			else {
				val = UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropLifeMax, c_unitPropCurrent) + val;
			}
		}
		else if(percent) {
			val = UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropLifeMax, c_unitPropCurrent)*(val/100);
		}
		if(UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropLifeMax, c_unitPropCurrent) + val < 0) {
			val = 1;
		}
		UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropLifeMax, val );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

bool librptr_command_maxshields(bool testConds, bool runActions) {
	string param;
	fixed val;
	bool percent = false;
	unitgroup g = librptr_player[EventPlayer()].context;
	bool absolute = true;
	
	param = StringWord( librptr_player[EventPlayer()].chat_msg, 2 );
	
	if( StringContains(param, "%", c_stringEnd, c_stringCase) ) {
		percent = true;
		param = StringSub(param, 1, StringLength(param)-1);
	}
	if( StringContains(param, "+", c_stringBegin, c_stringCase) ) {
		absolute = false;
		param = StringSub(param, 2, StringLength(param));
	}
	
	val = StringToFixed(param);

	if( val <= 0 && absolute) {
		return true;
	}
	
	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		if(!absolute) {
			if(percent) {
				val = UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropShieldsMax, c_unitPropCurrent) + (UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropShieldsMax, c_unitPropCurrent)*(val/100));
			}
			else {
				val = UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropShieldsMax, c_unitPropCurrent) + val;
			}
		}
		else if(percent) {
			val = UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropShieldsMax, c_unitPropCurrent)*(val/100);
		}
		if(UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropShieldsMax, c_unitPropCurrent) + val < 0) {
			val = 1;
		}
		UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropShieldsMax, val );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

bool librptr_command_maxenergy(bool testConds, bool runActions) {
	string param;
	fixed val;
	bool percent = false;
	unitgroup g = librptr_player[EventPlayer()].context;
	bool absolute = true;
	
	param = StringWord( librptr_player[EventPlayer()].chat_msg, 2 );
	
	if( StringContains(param, "%", c_stringEnd, c_stringCase) ) {
		percent = true;
		param = StringSub(param, 1, StringLength(param)-1);
	}
	if( StringContains(param, "+", c_stringBegin, c_stringCase) ) {
		absolute = false;
		param = StringSub(param, 2, StringLength(param));
	}
	
	val = StringToFixed(param);

	if( val <= 0 && absolute) {
		return true;
	}
	
	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		if(!absolute) {
			if(percent) {
				val = UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropEnergyMax, c_unitPropCurrent) + (UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropEnergyMax, c_unitPropCurrent)*(val/100));
			}
			else {
				val = UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropEnergyMax, c_unitPropCurrent) + val;
			}
		}
		else if(percent) {
			val = UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropEnergyMax, c_unitPropCurrent)*(val/100);
		}
		if(UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropEnergyMax, c_unitPropCurrent) + val < 0) {
			val = 1;
		}
		UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropEnergyMax, val );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

// librptr_command_liferegen
// librptr_command_shieldsregen
// librptr_command_energyregen
// =========================
// changes units life, shields, or energy regeneration
// can specify as absolute or as a percentage
// e.g. syntax: @liferegen 2 or @liferegen 2%
bool librptr_command_liferegen(bool testConds, bool runActions) {
	string param = StringWord( librptr_player[EventPlayer()].chat_msg, 2 );
	fixed val = StringToFixed(param);
	bool is_percent = false;
	unitgroup g = librptr_player[EventPlayer()].context;

	if( StringContains(param, "%", c_stringEnd, c_stringCase) ) {
		param = StringSub(param, 1, StringLength(param)-1);
		val = StringToFixed(param);
		is_percent = true;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		if(is_percent) {
			UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropLifeRegen,
				val * UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropLifeMax, false));
		}
		else {
			UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropLifeRegen, val );
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

bool librptr_command_shieldsregen(bool testConds, bool runActions) {
	string param = StringWord( librptr_player[EventPlayer()].chat_msg, 2 );
	fixed val = StringToFixed(param);
	bool is_percent = false;
	unitgroup g = librptr_player[EventPlayer()].context;

	if( StringContains(param, "%", c_stringEnd, c_stringCase) ) {
		param = StringSub(param, 1, StringLength(param)-1);
		val = StringToFixed(param);
		is_percent = true;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		if(is_percent) {
			UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropShieldsRegen,
				val * UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropShieldsMax, false));
		}
		else {
			UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropShieldsRegen, val );
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

bool librptr_command_energyregen(bool testConds, bool runActions) {
	string param = StringWord( librptr_player[EventPlayer()].chat_msg, 2 );
	fixed val = StringToFixed(param);
	bool is_percent = false;
	unitgroup g = librptr_player[EventPlayer()].context;

	if( StringContains(param, "%", c_stringEnd, c_stringCase) ) {
		param = StringSub(param, 1, StringLength(param)-1);
		val = StringToFixed(param);
		is_percent = true;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		if(is_percent) {
			UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropEnergyRegen,
				val * UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropEnergyMax, false));
		}
		else {
			UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropEnergyRegen, val );
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

// librptr_command_speed
// ==================
// sets a unit's speed (either for a single unit, or permanently for all)
bool librptr_command_speed(bool testConds, bool runActions) {
	string param = StringWord( librptr_player[EventPlayer()].chat_msg, 2 );
	fixed val;
	bool is_permanent = false;
	bool absolute = true;
	unitgroup g = librptr_player[EventPlayer()].context;
	
	is_permanent = StringContains(librptr_player[EventPlayer()].chat_msg, "all", c_stringAnywhere, false) ||
				  StringContains(librptr_player[EventPlayer()].chat_msg, "permanent", c_stringAnywhere, false);

	if( StringContains(param, "+", c_stringBegin, c_stringCase) ) {
		absolute = false;
		param = StringSub(param, 2, StringLength(param));
	}
	
	val = StringToFixed(param);

	if( val < 0 && absolute) {
		val = 0;
	}
	
	UnitGroupLoopBegin(g);
	if(is_permanent) {
		while(!UnitGroupLoopDone()) {
			if(!absolute) {
				val = UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropMovementSpeed, c_unitPropCurrent) + val;
				if(val < 0) {
					val = 0.0;
				}
			}
			CatalogFieldValueSet(c_gameCatalogUnit, UnitGetType(UnitGroupLoopCurrent()),
				"Speed", UnitGetOwner(UnitGroupLoopCurrent()), FixedToString(val, 4));
			UnitGroupLoopStep();
		}
	}
	else {
		while(!UnitGroupLoopDone()) {
			if(!absolute) {
				val = UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropMovementSpeed, c_unitPropCurrent) + val;
				if(val < 0) {
					val = 0.0;
				}
			}
			UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropMovementSpeed, val );
			UnitGroupLoopStep();
		}
	}
	UnitGroupLoopEnd();
	
	return true;
}

// librptr_command_height
// ====================
// sets a unit's z height
bool librptr_command_height(bool testConds, bool runActions) {
	fixed height;
	fixed time;
	string param;
	unitgroup g = librptr_player[EventPlayer()].context;
	param = StringWord( librptr_player[EventPlayer()].chat_msg, 2 );
	height = StringToFixed( param );
	param = StringWord( librptr_player[EventPlayer()].chat_msg, 3 );
	time = StringToFixed( param );

	UnitGroupLoopBegin(g);
	while( !UnitGroupLoopDone() ) {
		UnitSetHeight( UnitGroupLoopCurrent(), height, time );
		librptr_unit_cache_update(UnitGroupLoopCurrent(), "@height", librptr_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

// librptr_command_color
// ==================
// changes the player color of a unit
bool librptr_command_color(bool testConds, bool runActions) {
	int new_color;
	string param = StringWord( librptr_player[EventPlayer()].chat_msg, 2 );
	unitgroup g = librptr_player[EventPlayer()].context;
	
	new_color = librptr_color_to_player_default(param);
	if(new_color == -1) { // invalid entry by user
		return true;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		UnitSetTeamColorIndex( UnitGroupLoopCurrent(), new_color );
		librptr_unit_cache_update(UnitGroupLoopCurrent(), "@color", librptr_player[EventPlayer()].chat_msg);		
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

// librptr_command_invulnerable
// librptr_command_vulnerable
// ====================
// Makes a unit invulnerable or vulnerable
bool librptr_command_invulnerable(bool testConds, bool runActions) {
	unitgroup g = librptr_player[EventPlayer()].context;
	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		UnitSetState( UnitGroupLoopCurrent(), c_unitStateInvulnerable, true );
		librptr_unit_cache_update(UnitGroupLoopCurrent(), "@invulnerable", librptr_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}
bool librptr_command_vulnerable(bool testConds, bool runActions) {
	unitgroup g = librptr_player[EventPlayer()].context;
	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		UnitSetState( UnitGroupLoopCurrent(), c_unitStateInvulnerable, false );
		librptr_unit_cache_update(UnitGroupLoopCurrent(), "@invulnerable", "");
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

// librptr_command_face
// ===============
// makes a unit face an angle. (modified from Cortex engine)
// if no angle is specified, unit will face towards player's mouse cursor
bool librptr_command_face(bool testConds, bool runActions) {
	fixed angle;
	string param;
	unitgroup g = librptr_player[EventPlayer()].context;
	bool absolute = true;

	param = StringWord( librptr_player[EventPlayer()].chat_msg, 2 );
	if( param != "" ) {
		if( StringContains(param, "+", c_stringBegin, c_stringCase) ) {
			absolute = false;
			param = StringSub(param, 2, StringLength(param));
		}
		angle = StringToFixed( param );
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		if( param == "" ) { // face mouse
			libNtve_gf_MakeUnitFacePoint( UnitGroupLoopCurrent(), librptr_player[EventPlayer()].mouse_position, 0.0 );
		}
		else if(!absolute) {
			UnitSetFacing(UnitGroupLoopCurrent(), UnitGetFacing(UnitGroupLoopCurrent()) + angle, 0.0);
		}
		else { // face angle
			UnitSetFacing( UnitGroupLoopCurrent(), angle, 0.0 );
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

// librptr_command_damage
// =================
// deals with both adding or removing damage (modified from Cortex engine)
// both @adddamage and @removedamage are directed here
// max damage added or removed is currently set at 9999
bool librptr_command_damage(bool testConds, bool runActions) {
	string command = StringCase( StringWord( librptr_player[EventPlayer()].chat_msg, 1 ), false );
	string dmg_behavior_1;
	string dmg_behavior_10;
	string dmg_behavior_100;
	string dmg_behavior_1000;
	int amt;
	int val = StringToInt(StringWord( librptr_player[EventPlayer()].chat_msg, 2 ));
	unitgroup g = librptr_player[EventPlayer()].context;
	
	// since we are using the same command for both @adddamage and @removedamage,
	// check which command it is, and set proper behaviors
	if( (command == "@adddamage" && val > 0) || (command == "@removedamage" && val < 0) ) {
		dmg_behavior_1 = LIBRPTR_BEHAVIOR_ADD_DAMAGE_1;
		dmg_behavior_10 = LIBRPTR_BEHAVIOR_ADD_DAMAGE_10;
		dmg_behavior_100 = LIBRPTR_BEHAVIOR_ADD_DAMAGE_100;
		dmg_behavior_1000 = LIBRPTR_BEHAVIOR_ADD_DAMAGE_1000;
	}
	else { // we are using @removedamage
		dmg_behavior_1 = LIBRPTR_BEHAVIOR_SUBTRACT_DAMAGE_1;
		dmg_behavior_10 = LIBRPTR_BEHAVIOR_SUBTRACT_DAMAGE_10;
		dmg_behavior_100 = LIBRPTR_BEHAVIOR_SUBTRACT_DAMAGE_100;
		dmg_behavior_1000 = LIBRPTR_BEHAVIOR_SUBTRACT_DAMAGE_1000;
	}
	
	val = AbsI(val);
	if(val > 9999) {
	   val = 9999;
	}
	
	amt = val;

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		// First remove all damage bonuses and maluses, since we're now treating this as a "strictly positive setdamagebonus" command
		UnitBehaviorRemove( UnitGroupLoopCurrent(), LIBRPTR_BEHAVIOR_ADD_DAMAGE_1, -1);
		UnitBehaviorRemove( UnitGroupLoopCurrent(), LIBRPTR_BEHAVIOR_ADD_DAMAGE_10, -1);
		UnitBehaviorRemove( UnitGroupLoopCurrent(), LIBRPTR_BEHAVIOR_ADD_DAMAGE_100, -1);
		UnitBehaviorRemove( UnitGroupLoopCurrent(), LIBRPTR_BEHAVIOR_ADD_DAMAGE_1000, -1);
		UnitBehaviorRemove( UnitGroupLoopCurrent(), LIBRPTR_BEHAVIOR_SUBTRACT_DAMAGE_1, -1);
		UnitBehaviorRemove( UnitGroupLoopCurrent(), LIBRPTR_BEHAVIOR_SUBTRACT_DAMAGE_10, -1);
		UnitBehaviorRemove( UnitGroupLoopCurrent(), LIBRPTR_BEHAVIOR_SUBTRACT_DAMAGE_100, -1);
		UnitBehaviorRemove( UnitGroupLoopCurrent(), LIBRPTR_BEHAVIOR_SUBTRACT_DAMAGE_1000, -1);

		val = amt;
		
		// Add appropriate behaviors until they reach the desired total damage bonus
		while(val >= 1000) {
			UnitBehaviorAdd( UnitGroupLoopCurrent(), dmg_behavior_1000, UnitGroupLoopCurrent(), 1 );
			val -= 1000;
		}
		while(val >= 100) {
			UnitBehaviorAdd( UnitGroupLoopCurrent(), dmg_behavior_100, UnitGroupLoopCurrent(), 1 );
			val -= 100;
		}
		while(val >= 10) {
			UnitBehaviorAdd( UnitGroupLoopCurrent(), dmg_behavior_10, UnitGroupLoopCurrent(), 1 );
			val -= 10;
		}
		UnitBehaviorAdd( UnitGroupLoopCurrent(), dmg_behavior_1, UnitGroupLoopCurrent(), val );
		
		librptr_unit_cache_update(UnitGroupLoopCurrent(), "@adddamage", librptr_player[EventPlayer()].chat_msg);		
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	
	return true;
}

// librptr_command_range
// =================
// deals with both adding or removing weapon range (modified from Cortex engine)
// both @addrange and @removerange are directed here
// max range able to be added/removed is currently set as 100
bool librptr_command_range(bool testConds, bool runActions) {
	string command = StringCase( StringWord( librptr_player[EventPlayer()].chat_msg, 1 ), false );
	string range_behavior_1;
	string range_behavior_10;
	int range = StringToInt( StringWord( librptr_player[EventPlayer()].chat_msg, 2 ) );
	unitgroup g = librptr_player[EventPlayer()].context;

	// since we are using the same command for both @addrange and @removerange,
	// check which command it is, and set proper behaviors
	if( (command == "@addrange" && range > 0) || (command == "@removerange" && range < 0) ) {
		range_behavior_1 = LIBRPTR_BEHAVIOR_ADD_RANGE_1;
		range_behavior_10 = LIBRPTR_BEHAVIOR_ADD_RANGE_10;
	}
	else { // are removing range
		range_behavior_1 = LIBRPTR_BEHAVIOR_SUBTRACT_RANGE_1;
		range_behavior_10 = LIBRPTR_BEHAVIOR_SUBTRACT_RANGE_10;
	}

	range = AbsI(range);
	if(range > 100) {
		range = 100;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		UnitBehaviorRemove(UnitGroupLoopCurrent(), LIBRPTR_BEHAVIOR_ADD_RANGE_1, -1);
		UnitBehaviorRemove(UnitGroupLoopCurrent(), LIBRPTR_BEHAVIOR_ADD_RANGE_10, -1);
		UnitBehaviorRemove(UnitGroupLoopCurrent(), LIBRPTR_BEHAVIOR_SUBTRACT_RANGE_1, -1);
		UnitBehaviorRemove(UnitGroupLoopCurrent(), LIBRPTR_BEHAVIOR_SUBTRACT_RANGE_10, -1);

		UnitBehaviorAdd(UnitGroupLoopCurrent(), range_behavior_1, null, ModI(range, 10));
		UnitBehaviorAdd(UnitGroupLoopCurrent(), range_behavior_10, null, range / 10);

		librptr_unit_cache_update(UnitGroupLoopCurrent(), "@addrange", librptr_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

// librptr_command_armor
// ===============
// used for both @armor and @shieldsarmor
// sets a unit's armor to the amount given via behaviors
bool librptr_command_armor(bool testConds, bool runActions) {
	fixed armor = StringToFixed( StringWord( librptr_player[EventPlayer()].chat_msg, 2 ) );
	fixed armor_curr = 0;
	fixed armor_diff = 0;
	string behav_armor_add_p1;
	string behav_armor_add_1;
	string behav_armor_add_10;
	string behav_armor_subtract_p1;
	string behav_armor_subtract_1;
	string behav_armor_subtract_10;
	unit current;
	unitgroup g = librptr_player[EventPlayer()].context;
	
	if( StringCase( StringWord( librptr_player[EventPlayer()].chat_msg, 1 ), false ) == "@shieldsarmor" ) {
		behav_armor_add_p1 = LIBRPTR_BEHAVIOR_ADD_SHIELDSARMOR_P1;
		behav_armor_add_1 = LIBRPTR_BEHAVIOR_ADD_SHIELDSARMOR_1;
		behav_armor_add_10 = LIBRPTR_BEHAVIOR_ADD_SHIELDSARMOR_10;
		behav_armor_subtract_p1 = LIBRPTR_BEHAVIOR_SUBTRACT_SHIELDSARMOR_P1;
		behav_armor_subtract_1 = LIBRPTR_BEHAVIOR_SUBTRACT_SHIELDSARMOR_1;
		behav_armor_subtract_10 = LIBRPTR_BEHAVIOR_SUBTRACT_SHIELDSARMOR_10;
	}
	else { // using @armor
		behav_armor_add_p1 = LIBRPTR_BEHAVIOR_ADD_LIFEARMOR_P1;
		behav_armor_add_1 = LIBRPTR_BEHAVIOR_ADD_LIFEARMOR_1;
		behav_armor_add_10 = LIBRPTR_BEHAVIOR_ADD_LIFEARMOR_10;
		behav_armor_subtract_p1 = LIBRPTR_BEHAVIOR_SUBTRACT_LIFEARMOR_P1;
		behav_armor_subtract_1 = LIBRPTR_BEHAVIOR_SUBTRACT_LIFEARMOR_1;
		behav_armor_subtract_10 = LIBRPTR_BEHAVIOR_SUBTRACT_LIFEARMOR_10;
	}
	
	if(armor > 255) {
		armor = 255;
	}
	
	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		current = UnitGroupLoopCurrent();
		armor_curr = StringToFixed(CatalogFieldValueGet(c_gameCatalogUnit, UnitGetType(current), "LifeArmor", UnitGetOwner(current)));
		armor_diff = armor - armor_curr;
		
		// remove any existing armor behaviors
		UnitBehaviorRemove(current, behav_armor_add_p1, -1);
		UnitBehaviorRemove(current, behav_armor_add_1, -1);
		UnitBehaviorRemove(current, behav_armor_add_10, -1);
		UnitBehaviorRemove(current, behav_armor_subtract_p1, -1);
		UnitBehaviorRemove(current, behav_armor_subtract_1, -1);
		UnitBehaviorRemove(current, behav_armor_subtract_10, -1);

		if(armor_diff > 0) {
			while(armor_diff >= 10) {
				UnitBehaviorAdd(current, behav_armor_add_10, null, 1);
				armor_diff = armor_diff - 10;
			}
			while(armor_diff >= 1) {
				UnitBehaviorAdd(current, behav_armor_add_1, null, 1);
				armor_diff = armor_diff - 1;
			}
			while(armor_diff >= 0.1) {
				UnitBehaviorAdd(current, behav_armor_add_p1, null, 1);
				armor_diff = armor_diff - 0.1;
			}
		}
		else {
			while(armor_diff <= -10) {
				UnitBehaviorAdd(current, behav_armor_subtract_10, null, 1);
				armor_diff = armor_diff + 10;
			}
			while(armor_diff <= -1) {
				UnitBehaviorAdd(current, behav_armor_subtract_1, null, 1);
				armor_diff = armor_diff + 1;
			}
			while(armor_diff <= -0.1) {
				UnitBehaviorAdd(current, behav_armor_subtract_p1, null, 1);
				armor_diff = armor_diff + 0.1;
			}
		}
		
		if( StringCase( StringWord( librptr_player[EventPlayer()].chat_msg, 1 ), false ) == "@shieldsarmor" ) {
			librptr_unit_cache_update(UnitGroupLoopCurrent(), "@shieldsarmor", librptr_player[EventPlayer()].chat_msg);
		}
		else { // using @armor
			librptr_unit_cache_update(UnitGroupLoopCurrent(), "@armor", librptr_player[EventPlayer()].chat_msg);
		}
		
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

// librptr_command_weaponspeed
// =====================
// Changes the weapon speed of a unit (local change)
// Because behaviors can only apply a weapon speed multiplier, 
// to get target weapon speed we use formula
// W : original weapon speed
// Y : target weapon speed
// X : behavior stack, each behavior .9 or 1.1 weapon speed multiplier
// If Y > W : W(1.1)^X = Y
// If Y < W : W(0.9)^X = Y
// So we require stack X given by (floored to an int):
// If Y > W : X = log(Y/W)/log(1.1)
// If Y < W : X = log(Y/W)/log(0.9)
bool librptr_command_weaponspeed(bool testConds, bool runActions) {
	unitgroup g = librptr_player[EventPlayer()].context;
	fixed speed = StringToFixed( StringWord( librptr_player[EventPlayer()].chat_msg, 2 ) );
	fixed ratio = 0;
	int stack_required;
	string weapon;
	unit current;
	
	if(speed > 15) {
		speed = 15;
	}
	if(speed <= 0.1) {
		speed = 0.1;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		current = UnitGroupLoopCurrent();
		weapon = UnitWeaponGet(current, 1);
		if(weapon != "") {
			ratio = StringToFixed(CatalogFieldValueGet(c_gameCatalogWeapon, weapon, "Period", UnitGetOwner(current))) / speed;
		}
		else {
			ratio = speed;
		}

		UnitBehaviorRemove(current, LIBRPTR_BEHAVIOR_WEAPONSPEED_MULT_P9, -1);
		UnitBehaviorRemove(current, LIBRPTR_BEHAVIOR_WEAPONSPEED_MULT_1P1, -1);

		if(ratio > 1) { // apply 1.1 multiplier
			stack_required = FixedToInt( Log2(ratio)/Log2(1.1) );
			if( stack_required > 100 ) {
				stack_required = 100;
			}
			UnitBehaviorAdd(current, LIBRPTR_BEHAVIOR_WEAPONSPEED_MULT_1P1, null, stack_required);
		}
		else if( ratio < 1) { // ratio < 1: apply .9 multiplier
			stack_required = FixedToInt( Log2(ratio)/Log2(0.9) );
			if( stack_required > 100 ) {
				stack_required = 100;
			}
			UnitBehaviorAdd(current, LIBRPTR_BEHAVIOR_WEAPONSPEED_MULT_P9, null, stack_required);
		}

		librptr_unit_cache_update(UnitGroupLoopCurrent(), "@weaponspeed", librptr_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

// librptr_command_weaponspeedall
// ====================
// sets global weaponspeed for weapons on a unit
// (by changing the catalog weaponspeed value)
bool librptr_command_weaponspeedall(bool testConds, bool runActions) {
	unitgroup g = librptr_player[EventPlayer()].context;
	fixed speed = StringToFixed( StringWord( librptr_player[EventPlayer()].chat_msg, 2 ) );
	int index;
	string weapon;
	unit current;
	
	if(speed > 15) {
		speed = 15;
	}	
	if(speed <= 0.1) {
		speed = 0.1;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		current = UnitGroupLoopCurrent();
		index = UnitWeaponCount(current);
		while(index != 0) {
			weapon = UnitWeaponGet(current, 1);
			CatalogFieldValueSet(c_gameCatalogWeapon, UnitWeaponGet(current, index),
				"Period", UnitGetOwner(current), FixedToString(speed, -1));
			index -= 1;
		}

		UnitBehaviorRemove(current, LIBRPTR_BEHAVIOR_WEAPONSPEED_MULT_P9, -1);
		UnitBehaviorRemove(current, LIBRPTR_BEHAVIOR_WEAPONSPEED_MULT_1P1, -1);

		librptr_unit_cache_update(UnitGroupLoopCurrent(), "@weaponspeedall", librptr_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

// librptr_command_subtitle
// =================
// sets a unit's subtitle (underneath a unit name)
bool librptr_command_subtitle(bool testConds, bool runActions) {
	string val = librptr_player[EventPlayer()].chat_msg;
	unitgroup g = librptr_player[EventPlayer()].context;
	val = StringSub( val, StringFind(val, " ", c_stringCase)+1, StringLength(val)); // The remainder of the chat message.	

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		CatalogFieldValueSet(c_gameCatalogUnit, UnitGetType(UnitGroupLoopCurrent()), "Subtitle", UnitGetOwner(UnitGroupLoopCurrent()), val);
		librptr_unit_cache_update(UnitGroupLoopCurrent(), "@subtitle", librptr_player[EventPlayer()].chat_msg);	
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

// librptr_command_tooltip
// =====================
// sets a units tooltip, either the main tip or subtip
// (note: this is only visible to OTHER players)
bool librptr_command_tooltip(bool testConds, bool runActions) {
	unitgroup g = librptr_player[EventPlayer()].context;
	string description;
	bool subtip = false;
	
	if(StringWord( librptr_player[EventPlayer()].chat_msg, 2) == "") {
		return true;
	}

	if(StringEqual(StringWord( librptr_player[EventPlayer()].chat_msg, 2),"sub",c_stringNoCase)) {
		description = StringSub( librptr_player[EventPlayer()].chat_msg, StringLength(StringWord( librptr_player[EventPlayer()].chat_msg, 1)) + 2, StringLength(librptr_player[EventPlayer()].chat_msg));
		description = StringSub( description, StringLength(StringWord( description, 1)) + 2, StringLength(description));

		subtip = true;
	}
	else {
		description = StringSub( librptr_player[EventPlayer()].chat_msg, StringLength(StringWord( librptr_player[EventPlayer()].chat_msg, 1)) + 2, StringLength(librptr_player[EventPlayer()].chat_msg));
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		if(subtip) {
			UnitSetInfoSubTip(UnitGroupLoopCurrent(), StringToText(description));
		}
		else {
			UnitSetInfoTip(UnitGroupLoopCurrent(), StringToText(description));
		}
		librptr_unit_cache_update(UnitGroupLoopCurrent(), "@tooltip", librptr_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();		
	
	return true;
}

// librptr_command_copy
// ===============
// copies selected units:
// - stats, behaviors, orders, weapons
// - visuals (by parsing commands from source cache)
bool librptr_command_copy(bool testConds, bool runActions) {
	unitgroup g = librptr_player[EventPlayer()].context;
	unitgroup created = UnitGroupEmpty();
	unit source;
	unitgroup targets;
	unit target;
	int i;
	int cache;
	string source_unit_id;
	
	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		source = UnitGroupLoopCurrent();
		targets = UnitCreate(1, UnitGetType(source), c_unitCreateIgnorePlacement, UnitGetOwner(source), librptr_player[EventPlayer()].mouse_position, UnitGetFacing(source));
		target = UnitGroupUnit(targets, 1);
		
		//set the unit's id on data table
		librptr_unit_set_id(target);
		UnitSetCustomValue(target, LIBRPTR_UNIT_INDEX_CACHE_COUNT, 1);
		
		// add to created unit group
		UnitGroupAdd(created, target);

		UnitSetHeight(target, UnitGetHeight(source), 0);
		UnitSetState(target, c_unitStateInvulnerable, 
			UnitTestState(source, c_unitStateInvulnerable));
		UnitSetState(target, c_unitStatePaused, 
			UnitTestState(source, c_unitStatePaused));
		UnitSetState(target, c_unitStateHidden, 
			UnitTestState(source, c_unitStateHidden));
		UnitSetState(target, c_unitStateHighlightable, 
			UnitTestState(source, c_unitStateHighlightable));
		UnitSetState(target, c_unitStateIgnoreTerrainZ, 
			UnitTestState(source, c_unitStateIgnoreTerrainZ));
		UnitSetState(target, c_unitStateFidget, 
			UnitTestState(source, c_unitStateFidget));
		UnitSetState(target, c_unitStateTargetable, 
			UnitTestState(source, c_unitStateTargetable));
		UnitSetState(target, c_unitStateStatusBar, 
			UnitTestState(source, c_unitStateStatusBar));
		UnitSetState(target, c_unitStateTooltipable, 
			UnitTestState(source, c_unitStateTooltipable));
		UnitSetState(target, c_unitStateCursorable, 
			UnitTestState(source, c_unitStateCursorable));
		UnitSetState(target, c_unitStateHighlighted, 
			UnitTestState(source, c_unitStateHighlighted));
		UnitSetState(target, c_unitStateUsingSupply, 
			UnitTestState(source, c_unitStateUsingSupply));
		UnitSetPropertyFixed(target, c_unitPropLifeMax, 
			UnitGetPropertyFixed(source, c_unitPropLifeMax, true));
		UnitSetPropertyFixed(target, c_unitPropLife, 
			UnitGetPropertyFixed(source, c_unitPropLife, true));
		UnitSetPropertyFixed(target, c_unitPropLifeRegen, 
			UnitGetPropertyFixed(source, c_unitPropLifeRegen, true));
		UnitSetPropertyFixed(target, c_unitPropEnergyMax, 
			UnitGetPropertyFixed(source, c_unitPropEnergyMax, true));
		UnitSetPropertyFixed(target, c_unitPropEnergy, 
			UnitGetPropertyFixed(source, c_unitPropEnergy, true));
		UnitSetPropertyFixed(target, c_unitPropEnergyRegen, 
			UnitGetPropertyFixed(source, c_unitPropEnergyRegen, true));
		UnitSetPropertyFixed(target, c_unitPropShieldsMax, 
			UnitGetPropertyFixed(source, c_unitPropShieldsMax, true));
		UnitSetPropertyFixed(target, c_unitPropShields, 
			UnitGetPropertyFixed(source, c_unitPropShields, true));
		UnitSetPropertyFixed(target, c_unitPropShieldsRegen, 
			UnitGetPropertyFixed(source, c_unitPropShieldsRegen, true));
		UnitSetPropertyFixed(target, c_unitPropKills, 
			UnitGetPropertyFixed(source, c_unitPropKills, true));
		UnitSetPropertyFixed(target, c_unitPropMovementSpeed, 
			UnitGetPropertyFixed(source, c_unitPropMovementSpeed, true));
		UnitSetPropertyFixed(target, c_unitPropResources, 
			UnitGetPropertyFixed(source, c_unitPropResources, true));

		// Skipping implementing ability commands and their charges.
		// Skipping implementing the cargo contained in a unit
		// Skipping implementing unit magazines
		// Skipping implementing unit queues

		i = UnitBehaviorCountAll(source);
		while(i != 0) {
			UnitBehaviorAdd(target, UnitBehaviorGet(source, i), null,
				UnitBehaviorCount(source, UnitBehaviorGet(source, i)));
			UnitBehaviorSetDuration(target, UnitBehaviorGet(source, i),
				UnitBehaviorDuration(source, UnitBehaviorGet(source, i)));
			i -= 1;
		}

		i = 1;
		while(i <= UnitOrderCount(source)) {
			UnitIssueOrder(target, UnitOrder(source, i), c_orderQueueAddToEnd);
			i += 1;
		}

		i = UnitWeaponCount(target);
		while(i != 0) {
			UnitWeaponRemove(target, UnitWeaponGet(target, 1));
			i -= 1;
		}

		i = UnitWeaponCount(source);
		while(i != 0) {
			// Does not copy turrets!
			UnitWeaponAdd(target, UnitWeaponGet(source, i), null);
			i -= 1;
		}

		// Skipping implementing setname duplications
		// Copy the visuals via cache
		source_unit_id = FixedToString(UnitGetCustomValue(source, LIBRPTR_UNIT_INDEX_ID), 0);
		cache = 1;
		while( DataTableValueExists(true, source_unit_id + "." + IntToString(cache)) ) {
			librptr_chat_parse(DataTableGetString(true, source_unit_id + "." + IntToString(cache)), EventPlayer(), targets);		
			cache += 1;
		}

		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	librptr_player[EventPlayer()].context = created;
	
	return true;
}
