//=========================================================
//		Raptor Roleplaying Engine
//		Copyright (c) 2014 , Xethyr.407 [NA] / @90-proof
//=========================================================
// This software is distributed under the MIT License:
// <http://opensource.org/licenses/MIT>
//=========================================================

// libcrtx_command_kill
// ====================
// kills units in player unitgroup context
bool librptr_command_kill(bool testConds, bool runActions) {
	UnitGroupLoopBegin(librptr_player[EventPlayer()].context);
	while(!UnitGroupLoopDone()) {
		UnitKill( UnitGroupLoopCurrent() );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

// librptr_command_remove
// ====================
// removes units in player unitgroup context
bool librptr_command_remove(bool testConds, bool runActions) {
	UnitGroupLoopBegin(librptr_player[EventPlayer()].context);
	while(!UnitGroupLoopDone()) {
		UnitRemove(UnitGroupLoopCurrent());
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

// librptr_command_removearea
// =====================
// removes unit in a radius around mouse position
bool librptr_command_removearea(bool testConds, bool runActions) {
	unitgroup g;
	fixed radius = StringToFixed( StringWord( librptr_player[EventPlayer()].chat_msg, 2 ));
	if(radius == 0.0) {
		radius = 5.0;
	}

	g = UnitGroup( null, c_playerAny, RegionCircle( librptr_player[EventPlayer()].mouse_position, radius), null, 0 );
	g = librptr_enforce_unit_permissions(g, EventPlayer());

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		UnitRemove( UnitGroupLoopCurrent() );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	
	libNtve_gf_RemoveDeathModelsinRegion( RegionCircle( librptr_player[EventPlayer()].mouse_position, radius) );

	return true;
}

// librptr_command_cache
// ===================
// displays unit command cache info or values
bool librptr_command_cache(bool testConds, bool runActions) {
	string cache;
	string unit_caches;
	unitgroup g = librptr_player[EventPlayer()].context;
	
	cache = StringWord(librptr_player[EventPlayer()].chat_msg, 2);
	
	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		if(StringToInt(cache) == 0) { //display number of caches
			if(UnitGetCustomValue(UnitGroupLoopCurrent(), LIBRPTR_UNIT_INDEX_CACHE_COUNT) == 1 && !DataTableValueExists(true, FixedToString(UnitGetCustomValue(UnitGroupLoopCurrent(), LIBRPTR_UNIT_INDEX_ID), 0) + ".1")) {
				unit_caches = "0";
			}
			else {
				unit_caches = FixedToString(UnitGetCustomValue(UnitGroupLoopCurrent(), LIBRPTR_UNIT_INDEX_CACHE_COUNT), 0);
			}
			librptr_print_output("Unit " + UnitGetType(UnitGroupLoopCurrent()) + " has " + unit_caches + " command caches (type \"@cache #\" to view a cache)", EventPlayer());
		}
		else {
			if(DataTableValueExists(true, FixedToString(UnitGetCustomValue(UnitGroupLoopCurrent(), LIBRPTR_UNIT_INDEX_ID), 0) + "." + cache)) {
				librptr_print_output("Unit " + UnitGetType(UnitGroupLoopCurrent()) + " cache " + cache + ":<n/>" + DataTableGetString(true, FixedToString(UnitGetCustomValue(UnitGroupLoopCurrent(), LIBRPTR_UNIT_INDEX_ID), 0) + "." + cache), EventPlayer());
			}
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();	
	return true;
}

// librptr_command_give
// =================
// gives another player units 
bool librptr_command_give(bool testConds, bool runActions) {
	unitgroup g = librptr_player[EventPlayer()].context;
	int new_owner = librptr_color_to_player( StringWord(librptr_player[EventPlayer()].chat_msg, 2) ); 
	
	if(new_owner == -1) { // invalid entry by user
		return true;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		UnitSetOwner( UnitGroupLoopCurrent(), new_owner, true );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}
