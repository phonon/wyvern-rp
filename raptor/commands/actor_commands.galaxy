//=========================================================
//		Raptor Roleplaying Engine
//		Copyright (c) 2014 , Xethyr.407 [NA] / @90-proof
//=========================================================
// This software is distributed under the MIT License:
// <http://opensource.org/licenses/MIT>
//=========================================================

// libcrtx_command_scale
// ====================
// sets the scale of a unit's main actor for all units in context (modified from Cortex Engine)
// Syntax: @scale [x] [y] [z] [time-blend]
bool librptr_command_scale(bool testConds, bool runActions) {
	fixed x = 0;
	fixed y = 0;
	fixed z  = 0;
	fixed time = 0;
	string param_x = StringWord(librptr_player[EventPlayer()].chat_msg, 2);
	string param_y = StringWord(librptr_player[EventPlayer()].chat_msg, 3);
	string param_z = StringWord(librptr_player[EventPlayer()].chat_msg, 4);
	string param_time = StringWord(librptr_player[EventPlayer()].chat_msg, 5);
	unitgroup g = librptr_player[EventPlayer()].context;
	
	x = StringToFixed(param_x);
	y = StringToFixed(param_y);
	z = StringToFixed(param_z);

	if(y == 0.0) {
		y = x;
	}
	
	if(z == 0.0) {
		z = x;
	}
	
	// Verify bounds.
	x = MinF( librptr_settings.max_scale, x );
	x = MaxF( librptr_settings.min_scale, x );
	
	y = MinF( librptr_settings.max_scale, y );
	y = MaxF( librptr_settings.min_scale, y );
	
	z = MinF( librptr_settings.max_scale, z );
	z = MaxF( librptr_settings.min_scale, z );
	
	// get blend time
	if( param_time != "" ) {
		time = StringToFixed(param_time);
	}
	
	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		ActorSend(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()), "SetScale " + FixedToString(x, 4) + "," + FixedToString(y, 4)  + "," + FixedToString(z, 4) + " " + FixedToString(time, 3) );
		librptr_unit_cache_update(UnitGroupLoopCurrent(), "@scale", librptr_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	
	return true;	
}

// libcrtx_command_tint
// =================
// sets the tint of a unit's main actor for all units in context (modified from Cortex Engine) 
// Syntax: @tint [R] [G] [B] [Opacity] [HDR] [time-blend]
bool librptr_command_tint(bool testConds, bool runActions) {
	string paramOne;
	string paramTwo;
	string paramThree;
	string paramFour;
	string paramFive;
	string paramSix;

	int red;
	int green;
	int blue;
	fixed alpha;
	fixed hdr;
	fixed duration;

	string amsg;
	actorscope ascope;
	actor act;

	unitgroup g = librptr_player[EventPlayer()].context;

	paramOne = StringWord( librptr_player[EventPlayer()].chat_msg, 2 );
	paramTwo = StringWord( librptr_player[EventPlayer()].chat_msg, 3 );
	paramThree = StringWord( librptr_player[EventPlayer()].chat_msg, 4 );
	paramFour = StringWord( librptr_player[EventPlayer()].chat_msg, 5 );
	paramFive = StringWord( librptr_player[EventPlayer()].chat_msg, 6 );
	paramSix = StringWord( librptr_player[EventPlayer()].chat_msg, 7 );

	if( StringContains(paramOne, "%", c_stringAnywhere, false) ) {
		paramOne = StringSub(paramOne, 1, StringLength(paramOne)-1);
		red = FixedToInt( 255.0 * StringToFixed(paramOne)/100.0 );
	} else {
		red = StringToInt(paramOne);
	}
	
	if( StringContains(paramTwo, "%", c_stringAnywhere, false) ) {
		paramTwo = StringSub(paramTwo, 1, StringLength(paramTwo)-1);
		green = FixedToInt( 255.0 * StringToFixed(paramTwo)/100.0 );
	} else {
		green = StringToInt(paramTwo);
	}
	
	if( StringContains(paramThree, "%", c_stringAnywhere, false) ) {
		paramThree = StringSub(paramThree, 1, StringLength(paramThree)-1);
		blue = FixedToInt( 255.0 * StringToFixed(paramThree)/100.0 );
	} else {
		blue = StringToInt(paramThree);
	}
	
	if( StringContains(paramFour, "%", c_stringAnywhere, false) ) {
		paramFour = StringSub(paramFour, 1, StringLength(paramFour)-1);
		alpha = StringToFixed(paramFour)/100.0;
	} else {
		alpha = StringToFixed(paramFour);
	}

	if( paramFour == "" ) { // Unspecified, default to 1.0
		alpha = 1.0;
	}

	if( paramFive == "" ) { // Unspecified, default to 1.0
		hdr = 1.0;
	}
	else {
		hdr = StringToFixed(paramFive);
	}
	
	if( paramSix == "" ) { // Unspecified, default to 0
		duration = 0;
	}
	else {
		duration = StringToFixed(paramSix);
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		ActorSend(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()), "SetTintColor {" + IntToString(red) + "," + IntToString(green) + "," + IntToString(blue) + " " +
			FixedToString(hdr, c_fixedPrecisionAny) + "} {" + FixedToString(duration, c_fixedPrecisionAny) + "}");
		ActorSend(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()), "SetOpacity {" + FixedToString(alpha, c_fixedPrecisionAny) + "} {" + "0 }");
		librptr_unit_cache_update(UnitGroupLoopCurrent(), "@tint", librptr_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

// libcrtx_command_modelswap
// ======================
// Changes the model of the main actor of unit (modified from Cortex Engine)
// Syntax: @modelswap [model] [variation]
bool librptr_command_modelswap(bool testConds, bool runActions) {
	string model = StringWord(librptr_player[EventPlayer()].chat_msg, 2);
	string variation = StringWord(librptr_player[EventPlayer()].chat_msg, 3);
	string amsg;
	unitgroup g = librptr_player[EventPlayer()].context;

	model = librtpr_catalog_get(c_gameCatalogModel, model);
	if(model == null) {
		librptr_print_output("<c val=\"ff0000\">Unable to swap model</c>: No such model exists.", EventPlayer());
		return true;
	}
	
	amsg = "ModelSwap {" + model + "}";
	if( variation != "" && StringToInt(variation) >= 0 ) {
		amsg += " {" + variation + "}";
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		ActorSend(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()), amsg);
		librptr_unit_cache_update(UnitGroupLoopCurrent(), "@modelswap", librptr_player[EventPlayer()].chat_msg);
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return true;
}

// libcrtx_command_actormessage
// =======================
// Sends an ActorMessage to a unit (main or a actor reference) or to a global reference
// Optional reference is either ->[reference] for local scope (within a unit scope)
//							or	__[reference] for global scope (any actor on map)
// Syntax: @actormsg ->/__[reference] [msg]
bool librptr_command_actormessage(bool testConds, bool runActions) {
	unitgroup g = librptr_player[EventPlayer()].context;
	string target = StringWord( librptr_player[EventPlayer()].chat_msg, 2);
	bool target_scope_global = false;
	string amsg;
	int amsg_start_word_index = 1;
	int amsg_start_index;
	
	if(target == "") {
		return true;
	}
	
	// check the actor message target:
	// target is specified by @actrmsg ->[Target] [msg] OR @actrmsg __[Target] [msg]
	// e.g. @actrmsg ->_Unit SetTint 250,0,0 or @actrmsg ->::Main SetTint 250,0,0
	// default will use target ::Main (the main actor for a unit)
	// -> indicates local scope (unit actor) whereas __ indicates a global scope
	else if( StringSub(target,1,2) == "__" ) {
		target = StringSub(target, 3, StringLength(target));
		amsg_start_word_index = 2;
		target_scope_global = true;
	}
	else if( StringSub(target,1,2) == "->" ) {
		target = StringSub(target, 3, StringLength(target));
		amsg_start_word_index = 2;
	}
	else { // default target is ::Main (local unit scope)
		target = "::Main";
	}
	
	// get the actor message string (remainder of line)
	amsg_start_index = StringLength(StringWord( librptr_player[EventPlayer()].chat_msg, 1)) + 2;
	if( amsg_start_word_index == 2 ) { 
		amsg_start_index += StringLength(StringWord( librptr_player[EventPlayer()].chat_msg, 2)) + 1;
	}
	
	amsg = StringSub( librptr_player[EventPlayer()].chat_msg, amsg_start_index, StringLength(librptr_player[EventPlayer()].chat_msg));

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		if( target_scope_global ) {
			ActorSend(ActorFrom(target), amsg);
		}
		else {
			ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()), target, amsg);
			librptr_unit_cache_update(UnitGroupLoopCurrent(), "@actormsg", librptr_player[EventPlayer()].chat_msg);
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();	
	
	return true;
}

// libcrtx_command_attach
// =====================
// Attaches an actor or a model to a unit (modified @attach+ from Cortex Forge)
// Can optionally specify coordinate offsets, rotations, and site operations
// syntax: @attach {-m} [Actor/Model] [Point_#] [offX] [offY] [offZ] {{-r} [rotX] [rotY] [rotZ]} [SOp1] [SOp2] [SOp3]...
bool librptr_command_attach(bool testConds, bool runActions) {
	unitgroup g = librptr_player[EventPlayer()].context;
	int parse_offset = 0;
	int x;
	string actr = "{}";
	string model = "{}";
	string scope;
	string apoint;
	string apoint_index = "";
	string offset = null;
	string rotation = null;
	string SOp;
	string siteops = "";
	string actormsg;
	string attachPoints = "Origin Center Damage Engine Hardpoint Head Hit Overhead RallyPoint StatusBar Left Right Target Turret TurretY TurretZ Upgrade Weapon WeaponLeft WeaponRight";
	
	if(StringWord( librptr_player[EventPlayer()].chat_msg, 2) == "") {
		return true;
	}
	else if(StringWord( librptr_player[EventPlayer()].chat_msg, 2) == "-m") {
		model = StringWord( librptr_player[EventPlayer()].chat_msg, 3);
		parse_offset += 1;
	}
	else {
		actr = StringWord( librptr_player[EventPlayer()].chat_msg, 2);
	}
	
	if( actr == "listpoints" || model =="listpoints" ) {
		librptr_print("<c val=\"00ff00\">Available attach points</c>:<n/>" + attachPoints, PlayerGroupSingle(EventPlayer()));
		return true;
	}
	
	//Check actr/model is valid
	if(StringWord( librptr_player[EventPlayer()].chat_msg, 2) == "-m") { //do catalog check for model
		model = librtpr_catalog_get(c_gameCatalogModel, model);
		if(model == null) {
			librptr_print_output("<c val=\"ff0000\">Unable to attach actor model</c>: No such model exists.", EventPlayer());
			return true;
		}
	}
	else { //do catalog check for actor
		actr = librtpr_catalog_get(c_gameCatalogActor, actr);
		if(actr == null) {
			librptr_print_output("<c val=\"ff0000\">Unable to attach actor</c>: No such actor exists.", EventPlayer());
			return true;
		}
		scope = CatalogEntryScope( c_gameCatalogActor, actr );
		if( scope == "CActorEventMacro" || scope == "CActorSound" ) {
			librptr_print_output("<c val=\"ff0000\">Unable to attach actor</c>: Invalid actor.", EventPlayer());
			return true;
		}
	}
	
	//MODIFY ATTACH POINT STRING:
	//get apoint (attachment point)
	apoint = StringWord( librptr_player[EventPlayer()].chat_msg, 3 + parse_offset);
	if( apoint == "" ) { 
		apoint = "Origin";
	}
	if(StringContains(apoint, "_", c_stringAnywhere, c_stringNoCase)) {
		x = StringLength(apoint);
		while(StringSub(apoint, x, x) != "_") {
			x -= 1;
		}
		apoint_index = " " + StringSub(apoint, x+1, StringLength(apoint));
		apoint = StringSub(apoint, 1, x-1);
	}
	//check apoint is valid
	x = 1;
	while( StringWord(attachPoints, x) != "" ) {
		if( StringEqual(apoint, StringWord(attachPoints, x), false) ) {
			apoint = StringWord(attachPoints, x);
			x = -1;
			break;
		}
		x = x + 1;
	}
	
	if( x != -1 ) {
		apoint = "Origin";
		librptr_print_output("<c val=\"ff0000\">Warning</c>: Invalid attachment point, defaulting to Origin.<n/>You can obtain a list of attachment points by typing <c val=\"00ff00\">@attach listpoints</c>.", EventPlayer());
	}
	
	//remake the apoint string
	apoint = "{" + apoint + apoint_index + "}";
	
	//check for offset (if specified)
	if(StringWord( librptr_player[EventPlayer()].chat_msg, 4 + parse_offset) != "" 
		&& !StringContains(StringWord( librptr_player[EventPlayer()].chat_msg, 4 + parse_offset), "SOp", c_stringAnywhere, c_stringNoCase)
		&& StringWord( librptr_player[EventPlayer()].chat_msg, 4 + parse_offset) != "-r") {
		x = 0;
		offset = "";
		while(x < 3) {
			if(StringWord( librptr_player[EventPlayer()].chat_msg, 4 + parse_offset + x) != "") {
				offset += "," + FixedToString(StringToFixed(StringWord( librptr_player[EventPlayer()].chat_msg, 4 + parse_offset + x)), c_fixedPrecisionAny);
			}
			else {
				offset += ",0";
			}
			
			x += 1;
		}
		offset = StringSub(offset, 2, StringLength(offset));
		parse_offset += 3;
	}
	
	//check for local rotation (if specified)
	if(StringWord( librptr_player[EventPlayer()].chat_msg, 4 + parse_offset) == "-r") {
		parse_offset += 1;
		x = 0;
		rotation = "";
		if(offset == null) {
			offset = "0,0,0";
		}
		while(x < 3) {
			if(StringWord( librptr_player[EventPlayer()].chat_msg, 4 + parse_offset + x) != "") {
				rotation += "," + FixedToString(StringToFixed(StringWord( librptr_player[EventPlayer()].chat_msg, 4 + parse_offset + x)), c_fixedPrecisionAny);
			}
			else {
				rotation += ",0";
			}
			
			x += 1;
		}
		rotation = StringSub(rotation, 2, StringLength(rotation));
		parse_offset += 3;
	}
	
	//keep checking for specified site ops until reached end of string
	if(StringWord( librptr_player[EventPlayer()].chat_msg, 4 + parse_offset) != "") {
		x = 0;
		while(StringWord( librptr_player[EventPlayer()].chat_msg, 4 + parse_offset + x) != "") {
			if(StringContains(StringWord( librptr_player[EventPlayer()].chat_msg, 4 + parse_offset + x), "SOp", c_stringAnywhere, c_stringNoCase)) {
				SOp = StringWord( librptr_player[EventPlayer()].chat_msg, 4 + parse_offset + x);
				SOp = librtpr_catalog_get(c_gameCatalogActor, SOp);
				if(SOp == null) {
					librptr_print_output("<c val=\"ff0000\">Warning: Encounted invalid or unknown Site Op: Skipping", EventPlayer());
				}
				else {
					siteops = siteops + " " + SOp;
				}
			}
			x += 1;
		}
		if(siteops != "") {
			if(offset == null) {
				offset = "0,0,0";
			}
			if(rotation == null) {
				rotation = "{}";
			}
			siteops = StringSub(siteops, 2, StringLength(siteops));
			siteops = "{" + siteops + "}";
		}
	}
	
	//FINALLY create the actor msg (before send)
	actormsg = "AttachModelOffset " + actr + " " + model + " " + apoint;
	if(offset != null) {
		actormsg = actormsg + " " + offset;
	}
	if(rotation != null) {
		actormsg = actormsg + " " + rotation;
	}
	if(siteops != "") {
		actormsg = actormsg + " " + siteops;
	}
	
	// DEBUG: prints out actor message created
	// librptr_print_success("TEST: ACTORMSG = " + "\"" + actormsg + "\"", EventPlayer());
	
	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		ActorSend(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()), actormsg);
		
		// TODO: need to generalize actors that shouldnt update cache
		if(!StringContains(actr, "TalkIcon", c_stringAnywhere, c_stringNoCase)) { 
			librptr_unit_cache_update(UnitGroupLoopCurrent(), "@attach", librptr_player[EventPlayer()].chat_msg);
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	
	return true;
}
