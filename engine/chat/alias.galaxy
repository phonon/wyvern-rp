//=========================================================
//		Wyvern Roleplaying Engine
//		Copyright (c) 2014 , Xethyr.407 [NA] / @90-proof
//=========================================================
// This software is distributed under the MIT License:
// <http://opensource.org/licenses/MIT>
//=========================================================

const int LIBWYV_ALIAS_MAX_DEPTH = 10;	// max depth of recursive alias replacing (prevent infinite aliasing)
const string LIBWYV_BANK_SECTION_ALIAS = "aliases";

// libwyv_alias_command_redirect
// ===================
// gets "alias ..." command from parser, redirects to function
bool libwyv_alias_command_redirect(string command, int player) {
	string subcommand = StringWord(command, 2);
	string alias = "";
	string content = "";

	if( StringEqual(subcommand, "create", c_stringNoCase) ) {
		alias = StringWord(command, 3);

		// remove "alias" and "create" and the alias from chat msg
		content = StringReplaceWord(libwyv_player[player].chat_msg, "alias", "", 1, c_stringNoCase);
		content = StringReplaceWord(content, "create", "", 1, c_stringNoCase);
		content = libwyv_string_trim( StringSub(content, StringFind(content, alias, c_stringNoCase) + StringLength(alias) + 1, StringLength(content)) );

		if( content != "" ) {
			libwyv_bank_create(LIBWYV_BANK_SECTION_ALIAS, alias, content, player);
			libwyv_print_success("ALIAS CREATED: " + alias + "\n" + "[\'" + content + "\']", player);
		}
		else {
			libwyv_print_error("ALIAS CANNOT BE EMPTY", player);
		}

		return true;
	}
	else if( StringEqual(subcommand, "remove", c_stringNoCase) ) {
		alias = StringWord(command, 3);
		if( BankKeyExists(libwyv_player[player].bank_storage, LIBWYV_BANK_SECTION_ALIAS, alias) ) {
			libwyv_bank_remove(LIBWYV_BANK_SECTION_ALIAS, alias, player);
			libwyv_print_success("ALIAS REMOVED: " + alias, player);
		}
		else {
			libwyv_print_error("ALIAS " + alias + " DOES NOT EXIST", player);
		}
	}
	else if( StringEqual(subcommand, "removeall", c_stringNoCase) ) {
		libwyv_bank_section_remove_all(LIBWYV_BANK_SECTION_ALIAS, player);
		libwyv_print_success("ALL ALIASES REMOVED", player);
	}
	else if( StringEqual(subcommand, "list", c_stringNoCase) ) {
		libwyv_bank_section_dump(LIBWYV_BANK_SECTION_ALIAS, player);
	}
	else if( StringEqual(subcommand, "print", c_stringNoCase) ) {
		libwyv_bank_key_content_dump(LIBWYV_BANK_SECTION_ALIAS, StringWord(command, 3), player);
	}
	else if( BankKeyExists(libwyv_player[player].bank_storage, LIBWYV_BANK_SECTION_ALIAS, subcommand) ) {
		libwyv_bank_key_content_dump(LIBWYV_BANK_SECTION_ALIAS, subcommand, player);
	}
	else {
		libwyv_print_error("INVALID ALIAS COMMAND", player);
	}

	return false;
}

// libwyv_alias_sub
// ===================
// recursively find and replace aliases in a given string
string libwyv_alias_sub(string msg, int player, int recursion_depth) {
	string alias = StringWord(msg, 1);
	string subbed = "";
	int i = 1;

	if( recursion_depth > LIBWYV_ALIAS_MAX_DEPTH ) {
		return msg;
	}

	while( alias != "" ) {
		if( BankKeyExists( libwyv_player[player].bank_storage, LIBWYV_BANK_SECTION_ALIAS, alias ) ) {
			subbed = subbed + " " + libwyv_alias_sub(BankValueGetAsString(libwyv_player[player].bank_storage, LIBWYV_BANK_SECTION_ALIAS, alias), player, recursion_depth + 1);
		}
		else {
			subbed = subbed + " " + alias;
		}

		i += 1;
		alias = StringWord(msg, i);
	}

	// remove extra front end " " for return
	return StringSub(subbed, 2, StringLength(subbed));
}
