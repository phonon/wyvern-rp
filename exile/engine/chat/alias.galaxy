//=========================================================
//		Exile Roleplaying Engine
//		Copyright (c) 2014 , Xethyr.407 [NA] / @90-proof
//=========================================================
// This software is distributed under the MIT License:
// <http://opensource.org/licenses/MIT>
//=========================================================

const int LIBXIL_ALIAS_MAX_DEPTH = 10;	// max depth of recursive alias replacing (prevent infinite aliasing)
const string LIBXIL_BANK_SECTION_ALIAS = "alias";

// libxil_alias_command_redirect
// ===================
// gets "alias ..." command from parser, redirects to function
bool libxil_alias_command_redirect(string command, int player) {
	string subcommand = StringWord(command, 2);
	string alias = "";
	string content = "";
	
	if( StringEqual(subcommand, "create", c_stringNoCase) ) { 
		alias = StringWord(command, 3);
		
		// remove "alias" and "create" and the alias from chat msg
		content = StringReplaceWord(libxil_player[player].chat_msg, "alias", "", 1, c_stringNoCase);
		content = StringReplaceWord(content, "create", "", 1, c_stringNoCase);
		content = libxil_string_trim( StringSub(content, StringFind(content, alias, c_stringNoCase) + StringLength(alias) + 1, StringLength(content)) );
		
		if( content != "" ) { 
			libxil_bank_create(LIBXIL_BANK_SECTION_ALIAS, alias, content, player);
			libxil_print_success("ALIAS CREATED: " + alias + "\n" + "[\'" + content + "\']", player);
		}
		else {
			libxil_print_error("ALIAS CANNOT BE EMPTY", player);
		}
		
		return true;
	}
	else if( StringEqual(subcommand, "remove", c_stringNoCase) ) {
		alias = StringWord(command, 3);
		if( BankKeyExists(libxil_player[player].bank_storage, LIBXIL_BANK_SECTION_ALIAS, alias) ) {
			libxil_bank_remove(LIBXIL_BANK_SECTION_ALIAS, alias, player);
			libxil_print_success("ALIAS REMOVED: " + alias, player);
		}
		else {
			libxil_print_error("ALIAS " + alias + " DOES NOT EXIST", player);
		}
	}
	else if( StringEqual(subcommand, "removeall", c_stringNoCase) ) {
		libxil_bank_section_remove_all(LIBXIL_BANK_SECTION_ALIAS, player);
		libxil_print_success("ALL ALIASES REMOVED", player);
	}
	else if( StringEqual(subcommand, "list", c_stringNoCase) ) {
		libxil_bank_section_dump(LIBXIL_BANK_SECTION_ALIAS, player);
	}
	else if( StringEqual(subcommand, "print", c_stringNoCase) ) {
		libxil_bank_key_content_dump(LIBXIL_BANK_SECTION_ALIAS, StringWord(command, 3), player);
	}
	else if( BankKeyExists(libxil_player[player].bank_storage, LIBXIL_BANK_SECTION_ALIAS, subcommand) ) {
		libxil_bank_key_content_dump(LIBXIL_BANK_SECTION_ALIAS, subcommand, player);
	}
	else {
		libxil_print_error("INVALID ALIAS COMMAND", player);
	}
	
	return false;
}

// libxil_alias_sub
// ===================
// recursively find and replace aliases in a given string
string libxil_alias_sub(string msg, int player, int recursion_depth) {
	string alias = StringWord(msg, 1);
	string subbed = "";
	int i = 1;
	
	if( recursion_depth > LIBXIL_ALIAS_MAX_DEPTH ) {
		return msg;
	}
	
	while( alias != "" ) {
		if( BankKeyExists( libxil_player[player].bank_storage, LIBXIL_BANK_SECTION_ALIAS, alias ) ) {
			subbed = subbed + " " + libxil_alias_sub(BankValueGetAsString(libxil_player[player].bank_storage, LIBXIL_BANK_SECTION_ALIAS, alias), player, recursion_depth + 1);
		}
		else {
			subbed = subbed + " " + alias;
		}
		
		i += 1;
		alias = StringWord(msg, i);
	}

	// remove extra front end " " for return
	return StringSub(subbed, 2, StringLength(subbed));
}
