//=========================================================
//		Exile Roleplaying Engine
//		Copyright (c) 2014 , Xethyr.407 [NA] / @90-proof
//=========================================================
// This software is distributed under the MIT License:
// <http://opensource.org/licenses/MIT>
//=========================================================


// libxil_command_info
// ====================
// just prints out a line of text to everyone
bool libxil_command_info(bool testConds, bool runActions) {
	libxil_print_output("Exile Engine v" + IntToString(LIBXIL_BUILD_VERSION) + "." + IntToString(LIBXIL_BUILD_SUB_VERSION) + LIBXIL_BUILD_VERSION_MODIFIER, EventPlayer());
	return true;
}

// libxil_command_list_commands
// ===============
// prints out a list of all the commands registered
bool libxil_command_list_commands(bool testConds, bool runActions) {
	libxil_print_output("LISTING GAME COMMANDS:\n" + libxil_settings.commands, EventPlayer());
	return true;
}

// libxil_command_players
// ===============
// prints player info (name + color + permissions level)
bool libxil_command_players(bool testConds, bool runActions) {
	int player = 0;
	text player_info;
	text output = StringToText("> Listing players: ");
	
	while( player < LIBXIL_MAX_PLAYERS ) {
		if( PlayerStatus(player) != c_playerStatusUnused ) {
			if( PlayerStatus(player) == c_playerStatusActive || PlayerType(player) != c_playerTypeUser ) {
				player_info = libxil_player_name_colored(player) + StringToText(" (") + PlayerColorName(PlayerGetColorIndex(player, false)) + StringToText(")");
			} else { // player left: print info in grey
				player_info = TextWithColor( PlayerName(player) + StringToText(" (") + PlayerColorName(PlayerGetColorIndex(player, false)) + StringToText(") (Left)"), Color(35,35,35) );
			}
			
			// display mod or admin status
			if( libxil_player[player].permission_level == LIBXIL_PERMISSIONS_LEVEL_MOD ) {
				player_info = player_info + StringToText(" (Mod)");
			}
			else if( libxil_player[player].permission_level == LIBXIL_PERMISSIONS_LEVEL_ADMIN ) {
				player_info = player_info + StringToText(" (Admin)");
			}
			
			output = output + StringToText("\n") + player_info;
		}
		player += 1;
	}

	libxil_print_text(output, PlayerGroupSingle(EventPlayer()));

	return true;
}

// libxil_command_gamesetup
// ====================
// redirects to proper gamesetup saving/loading/removing commands
bool libxil_command_gamesetup(bool testConds, bool runActions) {
	string param;
	string gamesetup_name;
	string rgnName;
	region rgn = RegionEntireMap();
	int i;
	string gamesetup_list = "";
	
	if(StringWord(libxil_player[EventPlayer()].chat_msg, 2) == "") {
		return true;
	}
	
	param = StringWord(libxil_player[EventPlayer()].chat_msg, 2);
	
	if(StringEqual(param, "save", c_stringNoCase)) {
		gamesetup_name = StringWord(libxil_player[EventPlayer()].chat_msg, 3);
		if(gamesetup_name == "") {
			libxil_print_error("Invalid game setup name", EventPlayer());			
			return true;
		}
		// TODO: PROPER REGIONS
		if(StringWord(libxil_player[EventPlayer()].chat_msg, 4) != "") {
			if(StringSub(StringWord(libxil_player[EventPlayer()].chat_msg, 4), 1, 1) == "#") {
				rgnName = StringWord(libxil_player[EventPlayer()].chat_msg, 4);
				rgnName = StringSub(rgnName, 2, StringLength(rgnName)); // remove the #
				
				// TODO: Get region from rgnName
				
				if(rgn == null) {
					libxil_print_error("No region with that name exists!", EventPlayer());
					return true;
				}
				libxil_print_success("Saving region " + rgnName, EventPlayer());
			}
			else {
				libxil_print_error("Region name must be prefixed with '#' (e.g. a region named \"rgn\" must be entered as #rgn", EventPlayer());
				return true;				
			}
		}
		
		libxil_gamesetup_save(EventPlayer(), gamesetup_name, rgn);
		return true;
	}
	
	if(StringEqual(param, "load", c_stringNoCase)) {
		gamesetup_name = StringWord(libxil_player[EventPlayer()].chat_msg, 3);
		
		if(BankSectionExists(libxil_player[EventPlayer()].bank_storage, LIBXIL_BANK_GAMESETUP_PREFIX + gamesetup_name)) {
			libxil_print_text( libxil_player_name_colored(EventPlayer()) + StringToText(" is loading a gamesetup..."), PlayerGroupAll() );
			libxil_gamesetup_load(EventPlayer(), gamesetup_name);
			return true;
		}
		else {
			libxil_print_error("Game setup " + gamesetup_name + " does not exist", EventPlayer());
			return true;
		}
	}
	
	if(StringEqual(param, "remove", c_stringNoCase)) {
		gamesetup_name = StringWord(libxil_player[EventPlayer()].chat_msg, 3);
		
		if( libxil_gamesetup_remove(EventPlayer(), gamesetup_name) ) {
			libxil_print_success("Game setup \"" + gamesetup_name + "\" has been deleted", EventPlayer());
			return true;
		}
		else {
			libxil_print_error("Game setup \"" + gamesetup_name + "\" does not exist", EventPlayer());
			return true;
		}
	}
	
	if(StringEqual(param, "removeall", c_stringNoCase)) {
		i = BankSectionCount(libxil_player[EventPlayer()].bank_storage) - 1;
		
		while( i >= 0 ) {
			if( StringContains(BankSectionName(libxil_player[EventPlayer()].bank_storage, i), LIBXIL_BANK_GAMESETUP_PREFIX, c_stringBegin, c_stringNoCase) ) {
				BankSectionRemove(libxil_player[EventPlayer()].bank_storage, BankSectionName(libxil_player[EventPlayer()].bank_storage, i));
			}
			i -= 1;
		}
		BankSave(libxil_player[EventPlayer()].bank_storage);
		libxil_print_success("All game setups have been deleted", EventPlayer());
	
		return true;
	}
	
	if(StringEqual(param, "list", c_stringNoCase)) {
		i = BankSectionCount(libxil_player[EventPlayer()].bank_storage) - 1;

		while(i >= 0) {
			if( StringContains(BankSectionName(libxil_player[EventPlayer()].bank_storage, i), LIBXIL_BANK_GAMESETUP_PREFIX, c_stringBegin, c_stringNoCase) ) {
				gamesetup_name = BankSectionName(libxil_player[EventPlayer()].bank_storage, i);
				gamesetup_list = gamesetup_list + ", " + StringSub(gamesetup_name, 4, StringLength(gamesetup_name));
			}
			i -= 1;
		}
		
		if(gamesetup_list == "") {
			libxil_print_output("You have no saved game setups", EventPlayer());
			return true;
		}
		
		//remove the first comma
		gamesetup_list = StringSub(gamesetup_list, 3, StringLength(gamesetup_list));
		
		libxil_print_output("Listing gamesetups:\n" + gamesetup_list, EventPlayer());
		
		return true;
	}
	
	return true;
}

// libxil_command_control
// ==================
// gives a player control over another player's units (modified from Cortex Engine)
bool libxil_command_control(bool testConds, bool runActions) {
	string player = StringWord(libxil_player[EventPlayer()].chat_msg, 2);
	string target_player = StringWord(libxil_player[EventPlayer()].chat_msg, 3);
	string original = player;
	int i = 1;
	int context = EventPlayer();	// a player to be controlled/given control

	// if target player specified, trying to make two players control one another
	if( target_player != "" ) {
		context = libxil_color_to_player(player);
		player = target_player;
	}
	
	if( context == -1 ) { // Invalid player.
		return true;
	}
	
	// check permissions on context player
	else if( context != EventPlayer() && PlayerType(context) == c_playerTypeUser && libxil_player[EventPlayer()].permission_level <= libxil_player[context].permission_level ) {
		return true;
	}

	// if original player was "all", set control by
	// parsing command for each player
	if( original == "all" ) {
		while( i != LIBXIL_MAX_PLAYERS ) {
			// Issue this command over the next color.
			libxil_chat_parse("\\control " + libxil_color_from_player(i) + " " + target_player, EventPlayer(), libxil_player[EventPlayer()].context);
			i += 1;
		}
		return true;
	}
	
	
	// apply alliance control/spending
	while( i != LIBXIL_MAX_PLAYERS ) { 
		if( i == context || (libxil_color_to_player(player) != i && player != "all") ) {
			i += 1;
			continue;
		}

		if( PlayerType(i) != c_playerTypeUser ) { 
			PlayerSetAlliance( context, c_allianceIdControl, i, true );
			PlayerSetAlliance( context, c_allianceIdSpend, i, true );
			PlayerSetAlliance( i, c_allianceIdControl, context, true );
			PlayerSetAlliance( i, c_allianceIdSpend, context, true );			
		}
		else {
			PlayerSetAlliance( context, c_allianceIdControl, i, true );
			PlayerSetAlliance( context, c_allianceIdSpend, i, true );
			// Now check, do we have permission to modify this player's alliances, too?
			if( EventPlayer() == i || libxil_player[EventPlayer()].permission_level > libxil_player[i].permission_level ) {
				PlayerSetAlliance( i, c_allianceIdControl, context, true );
				PlayerSetAlliance( i, c_allianceIdSpend, context, true );	
			}
		}

		i += 1;
	}
	
	return true;
}

// libxil_command_uncontrol
// ======================
// stops unit spending/control between two players (Modified from Cortex Engine)
bool libxil_command_uncontrol(bool testConds, bool runActions) {
	string player = StringWord(libxil_player[EventPlayer()].chat_msg, 2);
	string target_player = StringWord(libxil_player[EventPlayer()].chat_msg, 3);
	string original = player;
	int i = 1;
	int context = EventPlayer();	// a player to be controlled/given control

	// if target player specified, trying to make two players control one another
	if( target_player != "" ) {
		context = libxil_color_to_player(player);
		player = target_player;
	}
	
	if( context == -1 ) { // Invalid player.
		return true;
	}
	
	// check permissions on context player
	else if( context != EventPlayer() && PlayerType(context) == c_playerTypeUser && libxil_player[EventPlayer()].permission_level <= libxil_player[context].permission_level ) {
		return true;
	}

	// if original player was "all", set control by 
	// parsing command for each player
	if( original == "all" ) {
		while( i != LIBXIL_MAX_PLAYERS ) {
			// Issue this command over the next color.
			libxil_chat_parse("\\control " + libxil_color_from_player(i) + " " + target_player, EventPlayer(), libxil_player[EventPlayer()].context);
			i += 1;
		}
		return true;
	}


	// apply alliance control/spending
	while( i != LIBXIL_MAX_PLAYERS ) { 
		if( i == context || (libxil_color_to_player(player) != i && player != "all") ) {
			i += 1;
			continue;
		}

		if( PlayerType(i) != c_playerTypeUser ) { 
			PlayerSetAlliance( context, c_allianceIdControl, i, false );
			PlayerSetAlliance( context, c_allianceIdSpend, i, false );
			PlayerSetAlliance( i, c_allianceIdControl, context, false );
			PlayerSetAlliance( i, c_allianceIdSpend, context, false );			
		}
		else {
			PlayerSetAlliance( context, c_allianceIdControl, i, false );
			PlayerSetAlliance( context, c_allianceIdSpend, i, false );
			// Now check, do we have permission to modify this player's alliances, too?
			if( EventPlayer() == i || libxil_player[EventPlayer()].permission_level > libxil_player[i].permission_level ) {
				PlayerSetAlliance( i, c_allianceIdControl, context, false );
				PlayerSetAlliance( i, c_allianceIdSpend, context, false );	
			}
		}

		i += 1;
	}
	
	return true;
}

// libxil_command_ally
// ==================
// allies another player, and if your permissions are greater
// than target player, also forces them to ally you
bool libxil_command_ally(bool testConds, bool runActions) {
	string player = StringWord(libxil_player[EventPlayer()].chat_msg, 2);
	string target_player = StringWord(libxil_player[EventPlayer()].chat_msg, 3);
	string original = player;
	int i = 1;
	int context = EventPlayer();	// a player to be controlled/given control

	// if target player specified, trying to make two players control one another
	if( target_player != "" ) {
		context = libxil_color_to_player(player);
		player = target_player;
	}
	
	if( context == -1 ) { // Invalid player.
		return true;
	}
	
	// check permissions on context player
	else if( context != EventPlayer() && PlayerType(context) == c_playerTypeUser && libxil_player[EventPlayer()].permission_level <= libxil_player[context].permission_level ) {
		return true;
	}

	// if original player was "all", set control by
	// parsing command for each player
	if( original == "all" ) {
		while( i != LIBXIL_MAX_PLAYERS ) {
			// Issue this command over the next color.
			libxil_chat_parse("\\ally " + libxil_color_from_player(i) + " " + target_player, EventPlayer(), libxil_player[EventPlayer()].context);
			i += 1;
		}
		return true;
	}
	
	
	// apply alliance control/spending
	while( i != LIBXIL_MAX_PLAYERS ) { 
		if( i == context || (libxil_color_to_player(player) != i && player != "all") ) {
			i += 1;
			continue;
		}

		if( PlayerType(i) != c_playerTypeUser ) { 
			libNtve_gf_SetAllianceOneWay( context, i, 1);
			libNtve_gf_SetAllianceOneWay( i, context, 1);
		}
		else {
			libNtve_gf_SetAllianceOneWay( context, i, 1);
			// Now check, do we have permission to modify this player's alliances, too?
			if( EventPlayer() == i || libxil_player[EventPlayer()].permission_level > libxil_player[i].permission_level ) {
				libNtve_gf_SetAllianceOneWay( i, context, 1);
			}
		}

		i += 1;
	}
	
	return true;
}

// libxil_command_unally
// ==================
// unallies another player. other player automatically
// will unally you also
bool libxil_command_unally(bool testConds, bool runActions) {
	string player = StringWord(libxil_player[EventPlayer()].chat_msg, 2);
	string target_player = StringWord(libxil_player[EventPlayer()].chat_msg, 3);
	string original = player;
	int i = 1;
	int context = EventPlayer();	// a player to be controlled/given control

	// if target player specified, trying to make two players control one another
	if( target_player != "" ) {
		context = libxil_color_to_player(player);
		player = target_player;
	}
	
	if( context == -1 ) { // Invalid player.
		return true;
	}
	
	// check permissions on context player
	else if( context != EventPlayer() && PlayerType(context) == c_playerTypeUser && libxil_player[EventPlayer()].permission_level <= libxil_player[context].permission_level ) {
		return true;
	}

	// if original player was "all", set control by
	// parsing command for each player
	if( original == "all" ) {
		while( i != LIBXIL_MAX_PLAYERS ) {
			// Issue this command over the next color.
			libxil_chat_parse("\\ally " + libxil_color_from_player(i) + " " + target_player, EventPlayer(), libxil_player[EventPlayer()].context);
			i += 1;
		}
		return true;
	}
	
	
	// apply alliance control/spending
	while( i != LIBXIL_MAX_PLAYERS ) { 
		if( i == context || (libxil_color_to_player(player) != i && player != "all") ) {
			i += 1;
			continue;
		}
		libNtve_gf_SetAllianceOneWay( context, i, 5);
		libNtve_gf_SetAllianceOneWay( i, context, 5);

		i += 1;
	}
	
	return true;
}

// libxil_command_remove_player
// ===================
// removes all of a specific players units from the map
bool libxil_command_remove_player(bool testConds, bool runActions) {
	int target_player = libxil_color_to_player( StringWord(libxil_player[EventPlayer()].chat_msg, 2) ); //GET PLAYER COLOR FROM STRING.
	unitgroup g;
	
	if( target_player == -1 ) {
		libxil_print_error("Invalid player", EventPlayer());
		return false;
	}
	
	// if target_player is not yourself or a non-user, do permissions check
	if ( target_player != EventPlayer() && PlayerType(target_player) == c_playerTypeUser ) {
		if( libxil_player[EventPlayer()].permission_level < LIBXIL_PERMISSIONS_LEVEL_MOD && 
			libxil_player[EventPlayer()].permission_level <= libxil_player[target_player].permission_level ) {
			libxil_print_error("You cannot remove someone of equal or greater rank than you (while not a moderator or admin)", EventPlayer());
			return false;
		}
	}
	
	// remove all of target player's units
	g = UnitGroup( null, target_player, RegionEntireMap(), UnitFilter(0, 0, 0, 0), 0 );
	UnitGroupLoopBegin(g);
	while( !UnitGroupLoopDone() ) {
		UnitRemove( UnitGroupLoopCurrent() );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	
	libxil_print_text(libxil_player_name_colored(target_player) + StringToText(" has been removed by ") + libxil_player_name_colored(EventPlayer()), PlayerGroupAll());

	return true;
}

// libxil_command_search
// ===================
// searches a catalog for a specific keyword, then prints out
// a set number of results. continued using "\search" with no parameters
// lists more search results, until none are left
bool libxil_command_search(bool testConds, bool runActions) {
	const int SEARCH_LIST_COUNT = 8;
	string type = StringCase( StringWord(libxil_player[EventPlayer()].chat_msg, 2), false );
	string query = StringCase( StringWord(libxil_player[EventPlayer()].chat_msg, 3), false );
	int catalog;
	int i;
	int count;
	string result;

	if(type == "ability" || type == "abilities") {
		catalog = c_gameCatalogAbil;
	}
	else if(type == "actor" || type == "actors") {
		catalog = c_gameCatalogActor;
	}
	else if(type == "behavior" || type == "behaviors") {
		catalog = c_gameCatalogBehavior;
	}
	else if(type == "effect" || type == "effects") {
		catalog = c_gameCatalogEffect;
	}
	else if(type == "footprint" || type == "footprints") {
		catalog = c_gameCatalogFootprint;
	}
	else if(type == "light" || type == "lights") {
		catalog = c_gameCatalogLight;
	}
	else if(type == "model" || type == "models") {
		catalog = c_gameCatalogModel;
	}
	else if(type == "decal" || type == "decals") {
		catalog = c_gameCatalogTexture;
	}
	else if(type == "turret" || type == "turrets") {
		catalog = c_gameCatalogTurret;
	}
	else if(type == "unit" || type == "units") {
		catalog = c_gameCatalogUnit;
	}
	else if(type == "upgrade" || type == "upgrades") {
		catalog = c_gameCatalogUpgrade;
	}
	else if(type == "validator" || type == "validators") {
		catalog = c_gameCatalogValidator;
	}
	else if(type == "weapon" || type == "weapons") {
		catalog = c_gameCatalogWeapon;
	}
	else if(libxil_player[EventPlayer()].search_index == -1) {
		libxil_print_output("Usage: \\search [ability|actor|behavior|weapon|validator|upgrade|unit|turret|light|footprint|model|decal] [what to search for]", EventPlayer());
		return true;
	}
	
	i = CatalogEntryCount(catalog);

	// Allow for multi-page query results
	if(type == "") {
		i = libxil_player[EventPlayer()].search_index;
		catalog = libxil_player[EventPlayer()].search_catalog;
		query  = libxil_player[EventPlayer()].search_last_query;
	}
	else if(type == "repeat") {
		i = libxil_player[EventPlayer()].search_index + SEARCH_LIST_COUNT;
		catalog = libxil_player[EventPlayer()].search_catalog;
		query  = libxil_player[EventPlayer()].search_last_query;
	}

	libxil_print(" ", PlayerGroupSingle(EventPlayer())); // newline for readability
	libxil_print_output("<h>Results for the word \"" + query + "\"</h>:", EventPlayer());
	
	count = SEARCH_LIST_COUNT;
	while(i != 0 && count != 0) {
		result = CatalogEntryGet(catalog, i);
		if(StringContains(result, query, c_stringAnywhere, c_stringNoCase) || query == "") {
			// hide "decal" results that aren't decals at all.
			if( catalog != c_gameCatalogTexture || StringContains(result, "Decal", c_stringAnywhere, c_stringNoCase) ) {
				libxil_print(result, PlayerGroupSingle(EventPlayer()));
				count -= 1;
			}
		}
		i -= 1;
	}

	if(count == 0 && i != 0) {
		libxil_print_output("<h>More results exist. Type \"\\search\" to see them.</h>", EventPlayer());
		libxil_player[EventPlayer()].search_index = i;
		libxil_player[EventPlayer()].search_last_query = query;
		libxil_player[EventPlayer()].search_catalog = catalog;
	}
	else {
		libxil_player[EventPlayer()].search_index = -1;
	}
	
	return true;
}

// libxil_command_replace
// ==================
// replaces an entry in a data catalog with another entry
// Note: This is a VERY insecure command, that could cause
// a lot of really weird things to happen ingame. More testing is
// needed to decide proper permissions for this
bool libxil_command_replace(bool testConds, bool runActions) {
	string type = StringCase( StringWord(libxil_player[EventPlayer()].chat_msg, 2), false );
	int catalog;
	string source = StringWord(libxil_player[EventPlayer()].chat_msg, 3);
	string replace = StringWord(libxil_player[EventPlayer()].chat_msg, 4);
	unitgroup g = libxil_player[EventPlayer()].context;
	
	if( source == "" || replace == "" ) {
		libxil_print_output("Usage: \\replace [ability|actor|behavior|weapon|validator|upgrade|unit|turret|light|footprint|model|decal] [SOURCE] [REPLACEMENT]", EventPlayer());
		return true;
	}
	
	if(type == "ability" || type == "abilities") {
		catalog = c_gameCatalogAbil;
	}
	else if(type == "actor" || type == "actors") {
		catalog = c_gameCatalogActor;
	}
	else if(type == "behavior" || type == "behaviors") {
		catalog = c_gameCatalogBehavior;
	}
	else if(type == "effect" || type == "effects") {
		catalog = c_gameCatalogEffect;
	}
	else if(type == "footprint" || type == "footprints") {
		catalog = c_gameCatalogFootprint;
	}
	else if(type == "light" || type == "lights") {
		catalog = c_gameCatalogLight;
	}
	else if(type == "model" || type == "models") {
		catalog = c_gameCatalogModel;
	}
	else if(type == "decal" || type == "decals") {
		catalog = c_gameCatalogTexture;
	}
	else if(type == "turret" || type == "turrets") {
		catalog = c_gameCatalogTurret;
	}
	else if(type == "unit" || type == "units") {
		catalog = c_gameCatalogUnit;
	}
	else if(type == "upgrade" || type == "upgrades") {
		catalog = c_gameCatalogUpgrade;
	}
	else if(type == "validator" || type == "validators") {
		catalog = c_gameCatalogValidator;
	}
	else if(type == "weapon" || type == "weapons") {
		catalog = c_gameCatalogWeapon;
	}
	else {
		libxil_print_output("Usage: \\replace [ability|actor|behavior|weapon|validator|upgrade|unit|turret|light|footprint|model|decal] [SOURCE] [REPLACEMENT]", EventPlayer());
		return true;
	}
	
	// get source and replace actual data names
	source = libxil_catalog_get(catalog, source);
	replace = libxil_catalog_get(catalog, replace);
	if( source == null || replace == null ) {
		libxil_print_error("Invalid [source] or [replace] entry", EventPlayer());
		return true;
	}
	
	// so \replace works on other players (owner of any selected units)
	if( UnitGroupCount(g, c_unitCountAlive) > 0 ) {
		UnitGroupLoopBegin(g);
		while(!UnitGroupLoopDone()) {
			if( UnitGetOwner(UnitGroupLoopCurrent()) == EventPlayer() || libxil_player[EventPlayer()].permission_level > libxil_player[UnitGetOwner(UnitGroupLoopCurrent())].permission_level ) {
				libxil_print_text( StringToText("> Replacing catalog entry for ") + libxil_player_name_colored(UnitGetOwner(UnitGroupLoopCurrent()))
								  + StringToText(" in " + type + ": " + source + " -> " + replace), PlayerGroupSingle(EventPlayer()) );
				CatalogLinkReplace(UnitGetOwner(UnitGroupLoopCurrent()), catalog, source, replace);
			}
			UnitGroupLoopStep();
		}
		UnitGroupLoopEnd();
	}
	else {
		libxil_print_output("Replacing catalog entry in " + type + ": " + source + " -> " + replace, EventPlayer() );
		CatalogLinkReplace(EventPlayer(), catalog, source, replace);
	}
	
	return true;
}

// 	libxil_command_minerals
// 	libxil_command_gas
// 	libxil_command_terrazine
// ======================
// Adds a number of resources to a player (default: 100000)
// e.g. syntax: \minerals 9001
bool libxil_command_minerals(bool testConds, bool runActions) {
    int param = StringToInt(StringWord(libxil_player[EventPlayer()].chat_msg, 2));
    if(param == 0) {
		param = 100000;
    }
    PlayerModifyPropertyInt( EventPlayer(), c_playerPropMinerals, c_playerPropOperAdd, param );
    return true;
}
bool libxil_command_gas(bool testConds, bool runActions) {
    int param = StringToInt(StringWord(libxil_player[EventPlayer()].chat_msg, 2));
    if(param == 0) {
		param = 100000;
    }
    PlayerModifyPropertyInt( EventPlayer(), c_playerPropVespene, c_playerPropOperAdd, param );
    return true;
}
bool libxil_command_terrazine(bool testConds, bool runActions) {
    int param = StringToInt(StringWord(libxil_player[EventPlayer()].chat_msg, 2));
    if(param == 0) {
		param = 100000;
    }
    PlayerModifyPropertyInt( EventPlayer(), c_playerPropTerrazine, c_playerPropOperAdd, param );
    return true;
}

// libxil_command_supply
// ===================
// Sets the player's built supply to a value (default 200)
bool libxil_command_supply(bool testConds, bool runActions) {
    int param = StringToInt(StringWord(libxil_player[EventPlayer()].chat_msg, 2));
    if(param == 0) {
		param = 200;
    }
    PlayerModifyPropertyInt( EventPlayer(), c_playerPropSuppliesMade, c_playerPropOperSetTo, param );
    return true;
}

// libxil_command_zoom
// =================
// Zooms out a player's camera (max distance: 128)
bool libxil_command_zoom(bool testConds, bool runActions) {
	int height = StringToInt( StringWord(libxil_player[EventPlayer()].chat_msg, 2 ));
	
	if( height == 0 ) { // reset camera for player
		CameraApplyInfo( EventPlayer(), CameraInfoDefault(), 2.0, -1, 10, false );
	}
	else {
		if(height > 128) {
			height = 128;
		}
		else if( height < 0 ) {
			height = 0;
		}
		CameraSetValue( EventPlayer(), c_cameraValueDistance, IntToFixed(height), 2.0, -1, 10 );
	}
	return true;
}

// libxil_command_light
// ==================
// Changes the map's lighting over a specified period of time
// if no light is specified, defaults to map terrain's lighting
bool libxil_command_light(bool testConds, bool runActions) {
	string light = StringWord(libxil_player[EventPlayer()].chat_msg, 2);
	fixed blend_time = StringToFixed(StringWord(libxil_player[EventPlayer()].chat_msg, 3));
	
	if( libxil_player[EventPlayer()].permission_level < LIBXIL_PERMISSIONS_LEVEL_MOD  ) {
		return true;
	}
	
	if(light == "") { // get default lighting for terrain set
		light = CatalogFieldValueGet(c_gameCatalogTerrain,  GameTerrainSet(), "Lighting", EventPlayer());
	}
	
	light = libxil_catalog_get(c_gameCatalogLight, light);
	if(light == null) {
		libxil_print_error("<c val=\"ff0000\">Unable to change lighting</c>: No such light exists.", EventPlayer());
		return true;
	}

	if(StringWord(libxil_player[EventPlayer()].chat_msg, 3) == "") {
		blend_time = 2;
	}

	GameSetLighting(light, blend_time);

	return true;
}

// libxil_command_blacklist
// =================
// handles blacklist functions 
// (add, remove, removeall, list) as subcommands
bool libxil_command_blacklist(bool testConds, bool runActions) {
	string sub_command;
	string sub_parameter;
	int player;
	string player_handle;
	
	sub_command = StringWord( libxil_player[EventPlayer()].chat_msg, 2 );
	sub_parameter = StringWord( libxil_player[EventPlayer()].chat_msg, 3 );

	//add player name and handle to blacklist
	if( sub_command == "add" ) {
		if(sub_parameter == "-h") { // syntax: "blacklist add -h [handle] [name]", directly add handle and name
			player_handle = StringWord( libxil_player[EventPlayer()].chat_msg, 4 );
			libxil_blacklist_add( EventPlayer(), player_handle, StringToText(StringWord( libxil_player[EventPlayer()].chat_msg, 5 )) );
			libxil_print_output( StringWord( libxil_player[EventPlayer()].chat_msg, 5 ) + " (" + player_handle + ") was added to blacklist", EventPlayer() );
			return true;
		}
		
		// else, add player from color to blacklist
		player = libxil_color_to_player(StringWord( libxil_player[EventPlayer()].chat_msg, 3 ));
		if( player == -1 || PlayerType(player) != c_playerTypeUser ) {
			libxil_print_error("Invalid player", EventPlayer());
			return false;
		}
		else if( player == EventPlayer() ) {
			libxil_print_error("Cannot blacklist yourself", EventPlayer());
			return false;
		}
		
		player_handle = PlayerHandle(player);
		
		if( BankKeyExists(libxil_player[EventPlayer()].bank_storage, LIBXIL_BANK_SECTION_BLACKLIST, player_handle) ) {
			libxil_print_error("Player already exists on blacklist!", EventPlayer());
			return false;
		}
		
		libxil_blacklist_add(EventPlayer(), player_handle, StringToText("<d Player=\"" + IntToString(player) + "\" GameValue=\"PlayerClanTag\"/> ") + PlayerName(player));
		libxil_print_text( StringToText("> ") + libxil_player_name_colored(player) + StringToText(" (" + PlayerHandle(player) + ") was added to blacklist"), PlayerGroupSingle(EventPlayer()) );

		return true;
	}
	// remove player name and handle from blacklist
	// syntax is "blacklist remove ID"
	// (ID input is given by sub_parameter)
	else if( sub_command == "remove" ) {
		if( BankKeyCount(libxil_player[EventPlayer()].bank_storage, LIBXIL_BANK_SECTION_BLACKLIST) == 0 ) {
			libxil_print_error("No players on blacklist.", EventPlayer());
			return false;
		}

		if( StringToInt(sub_parameter) <= BankKeyCount(libxil_player[EventPlayer()].bank_storage, LIBXIL_BANK_SECTION_BLACKLIST) &&
			StringToInt(sub_parameter) != 0 ) {
			player_handle = BankKeyName(libxil_player[EventPlayer()].bank_storage, LIBXIL_BANK_SECTION_BLACKLIST, StringToInt(sub_parameter) - 1); // (id - 1) because index starts at 0
			libxil_print_text( StringToText("> ") + BankValueGetAsText(libxil_player[EventPlayer()].bank_storage, LIBXIL_BANK_SECTION_BLACKLIST, player_handle) + StringToText(" was removed from blacklist"), PlayerGroupSingle(EventPlayer()) );
			libxil_blacklist_remove(EventPlayer(), player_handle);
			return true;
		}
		else {
			libxil_print_error("Invalid blacklist index", EventPlayer());
			return false;
		}
	}
	else if( sub_command == "removeall" ) { // removes blacklist section from bank
		BankSectionRemove(libxil_player[EventPlayer()].bank_storage, LIBXIL_BANK_SECTION_BLACKLIST);
		BankSave(libxil_player[EventPlayer()].bank_storage);
		libxil_print_output("All blacklist entries removed", EventPlayer());
	}
	else if(sub_command == "list") { // lists blacklist in table in format ( [ID:] + Handle + Name )
		if( BankKeyCount(libxil_player[EventPlayer()].bank_storage, LIBXIL_BANK_SECTION_BLACKLIST) == 0 ) {
			libxil_print_error("No players on blacklist.", EventPlayer());
			return false;
		}
		
		libxil_blacklist_list(EventPlayer());
		return true;
	}

	return true;
}
